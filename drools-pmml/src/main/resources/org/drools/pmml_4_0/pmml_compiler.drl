/*
 * Copyright 2011 JBoss Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.drools.pmml_4_0.compiler;

import org.drools.pmml_4_0.descr.*;
import org.drools.pmml_4_0.ModelMarker;
import org.mvel2.templates.*;
import java.util.Collections;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;

global StringBuilder theory;
global TemplateRegistry registry;
global java.util.Map fld2var;
global org.drools.pmml_4_0.PMML4Wrapper utils;



 function void applyTemplate(String templateName, Object context, TemplateRegistry registry, Map vars, StringBuilder builder) {

    CompiledTemplate template = (CompiledTemplate) registry.getNamedTemplate(templateName);
    builder.append( TemplateRuntime.execute(template, context, vars) );
 }



// the function is repeated here because of rule processDerivedField_MapValues
    function String format(String type, String val) {
        if (type == null) {
            return val;
        } else if ("Integer".equalsIgnoreCase(type)) {
			return val;
		} else if ("Float".equalsIgnoreCase(type)) {
			return val;
		} else if ("Double".equalsIgnoreCase(type)) {
			return val;
		} else if ("Boolean".equalsIgnoreCase(type)) {
			return val;
		} else if ("String".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("Date".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("Time".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("DateTime".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("DateDaysSince[0]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateDaysSince[1960]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateDaysSince[1970]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateDaysSince[1980]".equalsIgnoreCase(type)) {
			return val;
		} else if ("TimeSeconds".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[0]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[1960]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[1970]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[1980]".equalsIgnoreCase(type)) {
			return val;
		} else {
			return val;
		}
    }


//**********************************************************************************************************
//
//  COMPILATION RULES
//
//**********************************************************************************************************


//*********************************** HEADER SECTION *****************************************************//

rule "processHeader"
salience 9999
when
    $h : Header()
then
    HashMap map = new HashMap( 3 );
        map.put( "pack", utils.getPack() );
    applyTemplate( "pmml_header.drlt", $h, registry, map, theory );

    applyTemplate( "commonQueries.drlt", $h, registry, map, theory );

    retract( $h );
end


//*********************************** DATA DICTIONARY ****************************************************//



declare FieldMarker
    name : String   @key
    dataType : DATATYPE
end

declare TypeOfField
    name : String     @key
    dataType : DATATYPE
end



declare QueryMarker
    name : String
    context : String
end




rule "processDataDictionary"
when
    $dic : DataDictionary( $flds : dataFields )
    eval( ! utils.isModelBeanDefined("DataField") )
then
    utils.addModelBeanDefinition("DataField");
    applyTemplate("rootDataField.drlt", utils, registry, Collections.emptyMap(), theory);
end


rule "typeOfDataField"
dialect "mvel"
when
    $fld : DataField( $n : name, $t : dataType )
then
    insert( new FieldMarker( $n, $t ) );
    insertLogical( new TypeOfField( $n, $t ) );
end



rule "processDataField_define"
dialect "mvel"
salience 1
when
    $fld : DataField( $n : name, $t : dataType )
    not FieldMarker( name == $n )
    eval( ! utils.isModelBeanDefined( utils.compactUpperCase( $n ) ) )
then
    utils.addModelBeanDefinition( utils.compactUpperCase( $n ) );
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fullName", $fld.displayName );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "super", null );
        map.put( "type", utils.mapDatatype( $fld.dataType ) );
        map.put( "modelType", null );
        //map.put("cyclic",("1".equals($fld.isCyclic)));
        //map.put("categorical","categorical".equalsIgnoreCase($fld.optype.v alue));
        //map.put("continuous","continuous".equalsIgnoreCase($fld.optype.v alue));
        //map.put("ordinal","ordinal".equalsIgnoreCase($fld.optype.v alue));
    applyTemplate( "ioTypeDeclare.drlt", utils, registry, map, theory );
//    applyTemplate("updateIOField.drlt", utils, registry, map, theory);

end



rule "processDataField_entry"
dialect "mvel"
when
    $fld        : DataField( $vals : values , $isize : intervals )
    $validVals  : List( $vsize : size ) from collect (
        Value( property != "invalid", property != "missing" ) from $vals
    )
then
    HashMap map = new HashMap( 11 );
        map.put( "context", utils.context );
        map.put( "fullName", $fld.displayName );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "type", utils.mapDatatype( $fld.dataType ) );
        map.put( "cyclic", ( "1".equals( $fld.isCyclic ) ) );
        map.put( "notRestricted", ( $isize.size() == 0 && $vsize == 0 ) );
        map.put( "categorical", "categorical".equalsIgnoreCase( $fld.optype.value ) );
        map.put( "continuous", "continuous".equalsIgnoreCase( $fld.optype.value ) );
        map.put( "ordinal", "ordinal".equalsIgnoreCase( $fld.optype.value ) );
    applyTemplate( "inputFromEP.drlt", utils, registry, map, theory );
end



rule "processDataField_interValidation_fixLeft"
salience 999
dialect "java"
when
    $fld : DataField( $ivals : intervals )
    $i   : Interval( leftMargin == null ) from $ivals
then
    $i.setLeftMargin(-Double.MAX_VALUE);
end


rule "processDataField_interValidation_fixRight"
salience 999
dialect "mvel"
when
    $fld : DataField( $ivals : intervals )
    $i   : Interval( rightMargin == null ) from $ivals
then
    $i.setRightMargin(Double.MAX_VALUE);
end

rule "processDataField_interValidation"
dialect "mvel"
when
    $fld : DataField( $vals : values , $isize : intervals.size() > 0,
                      optype == OPTYPE.CONTINUOUS || optype == OPTYPE.ORDINAL )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("ivals",$fld.intervals);
    applyTemplate("intervalsOnDomainRestriction.drlt", utils, registry, map, theory);
end



rule "processDataField_valueValidation_valid"
dialect "mvel"
when
    $fld    : DataField( $vals : values, $vsize : values.size() > 0 )
    accumulate (
                $val : Value( property == null || (property != "missing" && property != "invalid") ) from $vals,
                $validz : collectList( utils.format( $fld, $val ) );
                $validz.size > 0
               )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "vals", $validz );
        map.put( "field", $fld );
    applyTemplate( "valuesOnDomainRestriction.drlt", utils, registry, map, theory );
end


rule "processDataField_valueValidation_missing"
dialect "mvel"
when
    $fld      : DataField( $vals : values, $vsize : values.size() > 0,
                      ( optype == OPTYPE.CONTINUOUS || optype == OPTYPE.CATEGORICAL ) )
    accumulate (
                $val : Value( property == "missing" ) from $vals,
                $missingz : collectList( utils.format( $fld, $val ) );
                $missingz.size > 0
               )
then
    HashMap map = new HashMap(7);
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "vals", $missingz );
        map.put( "field", $fld );
    applyTemplate( "valuesOnDomainRestrictionMissing.drlt", utils, registry, map, theory );
end


rule "processDataField_valueValidation_invalid"
dialect "mvel"
when
    $fld      : DataField( $vals : values, $vsize : values.size() > 0,
                           ( optype == OPTYPE.CONTINUOUS || optype == OPTYPE.CATEGORICAL ) )
    accumulate (
                $val : Value( property == "invalid" ) from $vals,
                $invalidz : collectList( utils.format( $fld, $val ) );
                $invalidz.size > 0
               )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "vals", $invalidz );
        map.put( "field", $fld );
    applyTemplate( "valuesOnDomainRestrictionInvalid.drlt", utils, registry, map, theory );
end






//***************************************************************************************************************
//   TRANSFORMATIONS
//***************************************************************************************************************




//***************************************************************************************************************
//        Derived Fields definition
//              The transformationDictionary includes a set of derived field
//***************************************************************************************************************


rule "processDerivedField_define"
dialect "mvel"
salience 1
when
    $fld : DerivedField( $n : name, $t :  dataType )
    not    FieldMarker( name == $n )
then
//    String opt = $fld.optype.v alue;
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fullName", $fld.displayName );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "type", utils.mapDatatype( $fld.dataType ) );
        map.put( "super", null );
        map.put( "modelType", null );
//        map.put("cyclic",false);
//        map.put("categorical","categorical".equalsIgnoreCase(opt));
//        map.put("continuous","continuous".equalsIgnoreCase(opt));
//        map.put("ordinal","ordinal".equalsIgnoreCase(opt));
    applyTemplate( "ioTypeDeclare.drlt", utils, registry, map, theory );
//    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end


rule "typeOfDerivedField"
dialect "mvel"
when
    $fld : DerivedField( $n : name, $t : dataType )
then
    insert( new FieldMarker( $n,$t ) );
    insertLogical( new TypeOfField( $n, $t ) );
end



//******************************************************************************************************************
//        Linear Transformations
//          Normalization, piecewise continuous
//******************************************************************************************************************


rule "processDerivedField_linearize_missing"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous )
           NormContinuous( this == $nc, $mapMissing : mapMissingTo != null )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $nc.field ) );
        map.put( "target", $mapMissing );
    applyTemplate( "mapMissingValues.drlt", utils, registry, map, theory );
end



rule "processDerivedField_linearize_piecewiseInterpolate"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms )
then
    int num = $tracts.size();
    int j = 1;
    while (j < num) {
        java.util.HashMap map = new java.util.HashMap();
            map.put( "context",utils.context );
            map.put( "name", utils.compactUpperCase( $fld.name ) );
            map.put( "origField", utils.compactUpperCase($nc.field));
            map.put( "xmin", ( (LinearNorm) $tracts.get( j-1 ) ).orig);
            map.put( "ymin", ( (LinearNorm) $tracts.get( j-1 ) ).norm );
            map.put( "xmax", ( (LinearNorm) $tracts.get( j ) ).orig );
            map.put( "ymax", ( (LinearNorm) $tracts.get( j ) ).norm );
            map.put( "index",j );
            map.put( "type", utils.mapDatatype( $type ) );
        applyTemplate( "linearTractNormalization.drlt", utils, registry, map, theory );
        j++;
    }
end


rule "processDerivedField_linearize_outliers_asMissing"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms, outliers == OUTLIERTREATMENTMETHOD.AS_MISSING_VALUES )
    $XMIN : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, min( $x ) )
    $XMAX : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, max( $x ) )
then
    HashMap map = new HashMap(7);
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $nc.field ) );
        map.put( "xmin", $XMIN );
        map.put( "xmax", $XMAX );
        map.put( "type", utils.mapDatatype( $type ) );
    applyTemplate( "normContOutliersAsMissing.drlt", utils, registry, map, theory );
end


//
rule "processDerivedField_linearize_outliers_asExtreme"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms, outliers == OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES  )
    $XMIN : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, min( $x ) )
    $XMAX : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, max( $x ) )
    $YMIN : Double() from accumulate ( LinearNorm( $y : norm ) from $tracts, min( $y ) )
    $YMAX : Double() from accumulate ( LinearNorm( $y : norm ) from $tracts, max( $y ) )

then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $nc.field ) );
        map.put( "xmin", $XMIN );
        map.put( "xmax", $XMAX );
        map.put( "ymin", $YMIN );
        map.put( "ymax", $YMAX );
        map.put( "type", utils.mapDatatype( $type ) );
    applyTemplate( "boundedLowerOutliers.drlt", utils, registry, map, theory );
    applyTemplate( "boundedUpperOutliers.drlt", utils, registry, map, theory );
end

rule "processDerivedField_linearize_outliers_asExtrapolate"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc,  $tracts : linearNorms , $norms : linearNorms,
                    outliers != OUTLIERTREATMENTMETHOD.AS_MISSING_VALUES,
                    outliers != OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $nc.field ) );
        map.put( "xmin", ((LinearNorm) ( $tracts.get(0) ) ).orig );
        map.put( "xmax", ((LinearNorm) ( $tracts.get(1) ) ).orig );
        map.put( "ymin", ((LinearNorm) ( $tracts.get(0) ) ).norm );
        map.put( "ymax", ((LinearNorm) ( $tracts.get(1) ) ).norm );
        map.put( "index", 0);
        map.put( "type", utils.mapDatatype( $type ) );
    applyTemplate( "lowerExtrapolateLinearTractNormalization.drlt", utils, registry, map, theory );

    int $N = $norms.size();
        map.put("xmin",((LinearNorm) ( $tracts.get($N-2) ) ).orig );
        map.put("xmax",((LinearNorm) ( $tracts.get($N-1) ) ).orig );
        map.put("ymin",((LinearNorm) ( $tracts.get($N-2) ) ).norm );
        map.put("ymax",((LinearNorm) ( $tracts.get($N-1) ) ).norm );
        map.put("index",$N);
    applyTemplate( "upperExtrapolateLinearTractNormalization.drlt", utils, registry, map, theory );
end



//******************************************************************************************************************
//        Constants and References
//
//******************************************************************************************************************


rule "processDerivedField_constant"
dialect "mvel"
when
    $fld : DerivedField( $c : constant, $type : dataType )
    Constant( this == $c, $x : value )
then
    HashMap map = new HashMap(7);
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "konst", $x );
        map.put( "type", $type );
    applyTemplate( "constantField.drlt", utils, registry, map, theory );
end



rule "processDerivedField_fieldRef"
dialect "mvel"
when
    $fld : DerivedField( $ref : fieldRef )
    FieldRef( this == $ref, $f : field)
then
    HashMap map = new HashMap(7);
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $f ) );
    applyTemplate( "aliasedField.drlt", utils, registry, map, theory );
end




 //******************************************************************************************************************
 //        NormDiscrete
 //
 //******************************************************************************************************************


rule "processDerivedField_normDiscrete_basicField"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $x : value)
    DataField( name == $f, $dataType : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $f ) );
        map.put( "target", utils.format( $dataType, $x ) );
    applyTemplate( "indicatorFieldYes.drlt", utils, registry, map, theory );
    applyTemplate( "indicatorFieldNo.drlt", utils, registry, map, theory );
end



rule "processDerivedField_normDiscrete_derivedField"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $x : value)
    DerivedField( name == $f, $dataType : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context);
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $f ) );
        map.put( "target", utils.format( $dataType, $x ) );
    applyTemplate( "indicatorFieldYes.drlt", utils, registry, map, theory );
    applyTemplate( "indicatorFieldNo.drlt", utils, registry, map, theory );
end



rule "processDerivedField_normDiscrete_mapMissing"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $m : mapMissingTo != null )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",$m);
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end


rule "processDerivedField_normDiscrete_cleanup"
dialect "mvel"
salience -5
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd )
then
    retract($nd);
end

 //******************************************************************************************************************
 //       Binning / DiscretizeBin
 //
 //******************************************************************************************************************



rule "processDerivedField_Discretize_mapMissing"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $m : mapMissingTo != null , $dataType : dataType)
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",utils.format($dataType,$m));
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Discretize_propagateMissing"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $m : mapMissingTo == null )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
    applyTemplate("propagateMissingValues.drlt", utils, registry, map, theory);
end

rule "processDerivedField_Discretize_defaultnull"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue == null, $bins : discretizeBins )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("bins",$bins);
    applyTemplate("outOfBinningMissing.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Discretize_default"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue != null, $bins : discretizeBins, $dataType : dataType )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("bins",$bins);
        map.put("target",utils.format($dataType,$d));
    applyTemplate("outOfBinningDefault.drlt", utils, registry, map, theory);
end



rule "processDerivedField_Discretize_bin"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
           Discretize( this == $dx, $f : field , $d : defaultValue != null, $bins : discretizeBins, $dataType : dataType )
    $bin : DiscretizeBin( $interval : interval, $x : binValue ) from $bins
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("intv",$interval);
        map.put("index",utils.nextCount());
        map.put("target",utils.format($dataType,$x));
    applyTemplate("intervalBinning.drlt", utils, registry, map, theory);
end



rule "processDerivedField_Discretize_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx )
then
    retract($dx);
end

 //******************************************************************************************************************
 //     Value Mapping
 //
 //******************************************************************************************************************

declare MapSupportBean
   ref : MapValues
   columns : Map
   types : Map
end

rule "processDerivedField_MapValues_support_init"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
           MapValues( this == $map )
then
    MapSupportBean msb = new MapSupportBean();
        msb.setRef($map);
        msb.setColumns(new HashMap());
        msb.setTypes(new HashMap());
    insertLogical( msb );
end

rule "processDerivedField_MapValues_support"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
           MapValues( this == $map, $fcpairs : fieldColumnPairs )
    $sup : MapSupportBean( ref == $map )
    $fcp : FieldColumnPair() from $fcpairs
then
    $sup.columns.put($fcp.column, $fcp.field);
end


rule "processDerivedField_MapValues_support2"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
           MapValues( this == $map, $fcpairs : fieldColumnPairs )
    $sup : MapSupportBean( ref == $map )
    $fcp : FieldColumnPair() from $fcpairs
    DataField( name == $fcp.field, $type : dataType )
then
    $sup.types.put($fcp.column, $type.value );
end


rule "processDerivedField_extract"
salience -1
when
    $fld : DerivedField( $map : mapValues )
           MapValues( this == $map, $rows : inlineTable.rows, $outColumn : outputColumn )
    $row : Row( $cells : content ) from $rows
then
    insertLogical( $row );
end


//TODO : can't use utils.format here, maybe a bug?
rule "processDerivedField_MapValues"
salience -2
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $rows : inlineTable.rows, $outColumn : outputColumn )
    $sup : MapSupportBean( ref == $map,
                           $colMap : columns != null, $keys : columns.keySet,
                           $typeMap : types != null, $tkeys : types.keySet )
    $row : Row( $cells : content, this memberOf $rows )
    $fieldRestrMap : java.util.HashMap() from accumulate (
        org.w3c.dom.Element( $tag : tagName != $outColumn, $text : textContent,
                             tagName memberOf $keys, tagName memberOf $tkeys ) from $cells,
        init( java.util.HashMap restr = new java.util.HashMap(); ),
        action(
            restr.put( $colMap.get( $tag ), format( $typeMap.get($tag), $text ) );
        ),
        result( restr )
    )
    org.w3c.dom.Element( $tag : tagName == $outColumn, $target : textContent ) from $cells
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "patterns", $fieldRestrMap );
        map.put( "index", utils.nextCount() );
        map.put( "target", utils.format( $fld.dataType.value, $target ) );
    applyTemplate( "mapping.drlt", utils, registry, map, theory );
end



rule "processDerivedField_MapValues_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $map : mapValues )
           MapValues( this == $map )
then
    retract($map);
end



 //******************************************************************************************************************
 //     Aggregations
 //
 //******************************************************************************************************************

rule "processDerivedField_Collect"
dialect "mvel"
when
    $fld : DerivedField( $ag : aggregate )
           Aggregate( this == $ag, $func : this.function == "multiset",
                      $groupBy : groupField, $afield : field, $constr : sqlWhere )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "groupBy", $groupBy );
        map.put( "afield", $afield );
        map.put( "constr", $constr );
    applyTemplate( "collect.drlt", utils, registry, map, theory );
end


rule "processDerivedField_Aggregation"
dialect "mvel"
when
    $fld : DerivedField( $ag : aggregate )
           Aggregate( this == $ag, $func : this.function != "multiset",
                      $groupBy : groupField, $afield : field, $constr : sqlWhere )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "groupBy", $groupBy);
        map.put( "afield", $afield);
        map.put( "dataType", utils.mapDatatype( $fld.dataType ) );
        map.put( "constr", $constr );
        map.put( "aggrFunc", $func );
    applyTemplate( "aggregate.drlt", utils, registry, map, theory );
end


rule "processDerivedField_Aggregate_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $agg : aggregate )
           Aggregate( this == $agg )
then
    retract($agg);
end



 //******************************************************************************************************************
 //     Functions
 //
 //******************************************************************************************************************


declare FunctionResult
    expr   : String
    father : Apply
end




rule "processDerivedField_Apply"
dialect "mvel"
salience -5
when
    $fld : DerivedField( $app : apply )
    $a : Apply( this == $app, $fun : this.function, $arity : constantsAndFieldRevesAndNormContinuouses.size() )
    accumulate (
        $res : FunctionResult( father == $a, $x : expr ),
        $args : collectList( $x );
        $args.size == $arity
    )
then
    String funExpr = utils.mapFunction($fun, $args);
    //System.err.println(">>>>>>>>>>>>>>>>>>>>>>>>>  Built bit " + funExpr);

    Map exprFieldList = new java.util.LinkedHashMap();
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "dataType", utils.mapDatatype( $fld.dataType ) );
        map.put( "funExpr", funExpr );
        map.put( "exprFieldList", fld2var );
    applyTemplate( "apply.drlt", utils, registry, map, theory );

    retract( $a );
    fld2var.clear();
end






rule "NestedConst"
dialect "mvel"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $c : Constant( this memberOf $expr, $x : value)
then
    //System.out.println("Visit const : " + $x + " child of " + $f);
    insertLogical( new FunctionResult( $x, $a ) );
end

rule "NestedRef"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $fr : FieldRef( this memberOf $expr, $x : field )
then
    //System.out.println("Visit field : " + $x + " child of " + $f + " || " + fld2var);
    if (! fld2var.containsKey($x)) {
        fld2var.put( $x, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult( (String) fld2var.get( $x ), $a ) );
end


rule "Scoop"
dialect "mvel"
salience -5
when
    $a  : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $a2 : Apply( this memberOf $expr, $f2 : this.function, $arity : constantsAndFieldRevesAndNormContinuouses.size() )
    accumulate (
        $res : FunctionResult( father == $a2, $x : expr ),
        $args : collectList( $x );
        $args.size == $arity
    )
then
    //System.err.println("Building bit for " + $f2 + " child of " + $f + " with args " + $args.size);
    String bit = utils.mapFunction( $f2, $args );
    //System.err.println("Built bit " + bit + ", result for " + $f);
    insertLogical( new FunctionResult( bit , $a ) );
    //System.err.println("Kill " + $f2 + "and its children results");
end




rule "NestedAggregate_onBasicField"
dialect "java"
salience -5
when
    $a     : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $agg   : Aggregate( this memberOf $expr, $aggField : field )
    $super : DataField( name == $aggField, $optype : optype, $dataType : dataType)
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName( name );
        mockField.setOptype( $optype );
        mockField.setDataType( $dataType );
        mockField.setAggregate( $agg );
    insertLogical( mockField );
    if ( ! fld2var.containsKey( name ) ) {
        fld2var.put( name, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult( (String) fld2var.get( name ), $a ) );
end


rule "NestedAggregate_onDerivedField"
dialect "java"
salience -5
when
    $a     : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $agg   : Aggregate( this memberOf $expr, $aggField : field )
    $super : DerivedField( name == $aggField, $optype : optype, $dataType : dataType )
then
    String name = "Inner" + utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName( name );
        mockField.setOptype( $optype );
        mockField.setDataType( $dataType );
        mockField.setAggregate( $agg );
    insertLogical( mockField );
    if ( ! fld2var.containsKey( name ) ) {
        fld2var.put( name, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedMapValues"
dialect "java"
salience -5
when
    $a   : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $map : MapValues( this memberOf $expr, $dataType : dataType  )
then
    String name = "Inner" + utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName( name );
        mockField.setDataType( $dataType );
        mockField.setMapValues( $map );
        mockField.setOptype( OPTYPE.CONTINUOUS );
    insertLogical( mockField );
    if ( ! fld2var.containsKey( name ) ) {
        fld2var.put( name, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult( (String) fld2var.get( name ), $a ) );
end


rule "NestedDiscretize"
dialect "java"
salience -5
when
    $a   : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $dix : Discretize( this memberOf $expr, $dataType : dataType  )
then
    String name = "Inner" + utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName( name );
        mockField.setDataType( $dataType );
        mockField.setDiscretize( $dix );
        mockField.setOptype( OPTYPE.CATEGORICAL );
    insertLogical( mockField );
    if ( ! fld2var.containsKey( name ) ) {
        fld2var.put( name, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult( (String) fld2var.get( name ), $a ) );
end


rule "NestedNormContinuous"
dialect "java"
salience -5
when
    $a   : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $nct : NormContinuous( this memberOf $expr  )
then
    String name = "Inner" + utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName( name );
        mockField.setDataType( DATATYPE.DOUBLE );
        mockField.setNormContinuous( $nct );
        mockField.setOptype( OPTYPE.CONTINUOUS );
    insertLogical( mockField );
    if ( ! fld2var.containsKey( name ) ) {
        fld2var.put( name, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult( (String) fld2var.get( name ), $a ) );
end



rule "NestedNormDiscrete"
dialect "java"
salience -5
when
    $a   : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $ndx : NormDiscrete( this memberOf $expr  )
then
    String name = "Inner" + utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName( name );
        mockField.setDataType( DATATYPE.DOUBLE );
        mockField.setNormDiscrete( $ndx );
        mockField.setOptype( OPTYPE.CATEGORICAL );
    insertLogical( mockField );
    if ( ! fld2var.containsKey( name ) ) {
        fld2var.put( name, "$var" + fld2var.size() );
    }
    insertLogical( new FunctionResult( (String) fld2var.get( name ), $a ) );
end





  //******************************************************************************************************************
  //     User-defined Functions
  //
  //******************************************************************************************************************




declare MatchContext
    father : Apply @key
    root   : Apply @key
    body   : Object
    params : Map
end


rule "visitApply_user_root"
salience 15
no-loop
when
    $a :  Apply( $args : constantsAndFieldRevesAndNormContinuouses, $fun : this.function  )
          DefineFunction( name == $fun, apply != $a )
    $df : DerivedField( apply == $a )
then
    retract( $a );
    Apply idApply = new Apply();
       idApply.setFunction( "identity" );
        idApply.getConstantsAndFieldRevesAndNormContinuouses().add( $a );
    modify ( $df ) {
       setNormContinuous( null ),
       setApply( idApply );
    }
end



rule "visitApply_user_nested"
salience -1
no-loop
when
    $a      : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $fun : this.function  )
              DefineFunction( name == $fun, $body : apply != $a, $paramFields : parameterFields )
    $father : Apply( $superArgs : constantsAndFieldRevesAndNormContinuouses contains $a )
    $params : java.util.LinkedHashMap() from accumulate (
        ParameterField( $name : name, $type : dataType ) from $paramFields,
        init( java.util.LinkedHashMap map = new java.util.LinkedHashMap(); int j = 0; ),
        action( map.put($name,new Integer(j++)); ),
        result( map )
    )
then
    //System.out.println("\n\nINTERCEPTED USER-DEFINED APPLY " + $fun + " with params " + $params + " and args " + $expr.size() );

    // copy the function body to instantiate it
    Apply bodyInstance = (Apply) utils.copy( $body );
     MatchContext mc = new MatchContext(
        $father,
        $a,
        bodyInstance.getConstantsAndFieldRevesAndNormContinuouses().get( 0 ),
        $params );
    //System.out.println("\t About to insert context for");
    //System.out.println("\t\t father : " + $father);
    //System.out.println("\t\t root : " + $a);
    //System.out.println("\t\t body : " + mc.getBody());
    //System.out.println("\t\t ctx : " + $params + "\n\n");
     insert( mc );
end



rule "pre_visit_mc"
no-loop
salience 1000
when
    MatchContext( $body : body )
then
    insertLogical( $body );
end


rule "visit_mc"
no-loop
salience -1
when
           MatchContext( $body : body, $params : params, $root : root )
           Apply( this == $root, $args : constantsAndFieldRevesAndNormContinuouses )
    $a   : Apply( $bodyArgs : constantsAndFieldRevesAndNormContinuouses )
    $ref : FieldRef( this memberOf $bodyArgs, $fname : field )
    java.util.LinkedHashMap( keySet contains $fname ) from $params
then
    //System.out.println("MC with body and args, found ref  " + $ref);
    int index = $bodyArgs.indexOf( $ref );
    $bodyArgs.remove( index );
    Object arg = $args.get( (Integer) $params.get( $fname ) );
    $bodyArgs.add( index, utils.copy( arg ) );
     //System.out.println("REPLACE fieldRef in function " + $fname + " with " + arg + " in context " + $params);
end




rule "rebuildApply"
salience -1
no-loop
when
    $mc : MatchContext( $father: father, $a : root, $newbody : body )
          Apply(  this == $a, $expr : constantsAndFieldRevesAndNormContinuouses, $fun : this.function  )
          DefineFunction( name == $fun )
          Apply( this == $father, $superArgs : constantsAndFieldRevesAndNormContinuouses )
then
    //System.out.println("\t After some processing: matchContext ");
    //System.out.println("\t\t father : " + $mc.getFather());
    //System.out.println("\t\t root : " + $mc.getRoot());
    //System.out.println("\t\t body : " + $mc.getBody());
    //System.out.println("\t\t ctx : " + $mc.getParams() + "\n\n");
    retract( $newbody );

    //System.out.println("REBUILD APPLY " + $fun + " with " + $newbody);
    int index = $superArgs.indexOf( $a );
    $superArgs.remove( index );
    $superArgs.add( index, $newbody );
     //System.out.println("FATHER IS NOW  " + $father);
    retract( $mc );
    modify( $father ) {}
end







//**********************************************************************************************************
//
//  MODELS
//
//**********************************************************************************************************

declare ModelStat
    neuralNetwork : boolean
end

rule "InitStats"
when

then
    insert( new ModelStat() );
end


//**********************************************************************************************************
//
//  GENERAL STRUCTURE
//
//**********************************************************************************************************


declare DataMatrix
    rows    : int
    cols    : int
    src     : Matrix
end

declare StringMatrix extends DataMatrix
    data    : String[][]
end

declare IntMatrix extends DataMatrix
    data    : Integer[][]
end

declare DoubleMatrix extends DataMatrix
    data    : Double[][]
end


rule "Support Matrix Runtime"
when
    $mat : Matrix( )
then
    applyTemplate( "common.drlt", utils, registry, null, theory );
end


rule "Create Sparse Matrix"
when
    $mat : Matrix( $cells : matCells, arraies.size() == 0, $nc : nbCols, $nr : nbRows )
    accumulate ( $cell : MatCell( $j : row.intValue(), $k : col.intValue(), $val : value ) from $cells,
                 $rows : max( $j ),
                 $cols : max( $k );
                 $rows > 0 && $cols > 0
               )
then
    int c = $nc != null ? Math.max( $nc.intValue(), $cols.intValue() ) : $cols.intValue();
    int r = $nr != null ? Math.max( $nr.intValue(), $rows.intValue() ) : $rows.intValue();
    insert( new DoubleMatrix( r, c, $mat, new Double[ r ][ c ] ) );
end


rule "Init Sparse Matrix Diagonal"
salience 100
when
    $dat : DoubleMatrix( $nc : cols, $nr : rows == $nr, $data : data )
    $mat : Matrix( $cells : matCells, arraies.size() == 0,
                   $diag : diagDefault != null && != 0.0 )
then
    for ( int j = 0; j < $nr; j++ ) {
        $data[ j ][ j ] = $diag;
    }
end

rule "Init Sparse Matrix"
salience 100
when
    $dat : DoubleMatrix( $nc : cols, $nr : rows, $data : data )
    $mat : Matrix( $cells : matCells, arraies.size() == 0,
                   $off : offDiagDefault != null && != 0.0 )
then
    for ( int j = 0; j < $nr; j++ ) {
        for ( int k = 0; k < $nc; k++ ) {
            if ( j != k ) {
                $data[ j ][ k ] = $off;
            }
        }
    }
end


rule "Build Sparse Matrix"
when
    $dat : DoubleMatrix( $nc : cols, $nr : rows == $nr, $data : data )
    $mat : Matrix( $cells : matCells, arraies.size() == 0, $kind : kind )
    $cel : MatCell( $row : row.intValue(), $col : col.intValue(), $val : value ) from $cells
then
    $data[ $row - 1 ][ $col - 1 ] = Double.valueOf( $val );
    if ( "symmetric".equals( $kind ) ) {
        $data[ $col - 1 ][ $row - 1 ] = Double.valueOf( $val );
    }
end




rule "Create Arrayed Matrix - Int"
when
    $mat : Matrix( $cells : matCells, $arrays : arraies,
                   $rows : arraies.size() > 0,
                   $cols : arraies[0].n.intValue(),
                   arraies[0].type == "int" )
then
    insert( new IntMatrix( $rows, $cols, $mat, new Integer[ $rows ][ $cols ] ) );
end

rule "Create Arrayed Matrix - Double"
when
    $mat : Matrix( $cells : matCells, $arrays : arraies,
                   $rows : arraies.size() > 0,
                   $cols : arraies[0].n.intValue(),
                   arraies[0].type == "double" )
then
    insert( new DoubleMatrix( $rows, $cols, $mat, new Double[ $rows ][ $cols ] ) );
end

rule "Create Arrayed Matrix - String"
when
    $mat : Matrix( $cells : matCells, $arrays : arraies,
                   $rows : arraies.size() > 0,
                   $cols : arraies[0].n.intValue(),
                   arraies[0].type == "string" )
then
    insert( new StringMatrix( $rows, $cols, $mat, new String[ $rows ][ $cols ] ) );
end

rule "Fill matrix from double arrays"
when
    $dat : DoubleMatrix( $data : data )
    $mat : Matrix( $arrays : arraies, arraies.size() > 0 )
    $arr : Array( $row : content ) from $arrays
then
    int rowIndex = $arrays.indexOf( $arr );
    String[] row = utils.tokenize( $row );
    for ( int j = 0; j < $data[0].length; j++ ) {
        $data[ rowIndex ][ j ] = Double.valueOf( row[ j ] );
    }
end

rule "Fill matrix from int arrays"
when
    $dat : IntMatrix( $data : data )
    $mat : Matrix( $arrays : arraies, arraies.size() > 0 )
    $arr : Array( $row : content ) from $arrays
then
    int rowIndex = $arrays.indexOf( $arr );
    String[] row = utils.tokenize( $row );
    for ( int j = 0; j < $data[0].length; j++ ) {
        $data[ rowIndex ][ j ] = Integer.valueOf( row[ j ] );
    }
end

rule "Fill matrix from String arrays"
when
    $dat : StringMatrix( $data : data )
    $mat : Matrix( $arrays : arraies, arraies.size() > 0 )
    $arr : Array( $row : content ) from $arrays
then
    int rowIndex = $arrays.indexOf( $arr );
    String[] row = utils.tokenize( $row );
    for ( int j = 0; j < $data[0].length; j++ ) {
        $data[ rowIndex ][ j ] = row[ j ];
    }
end



query formatArray( Array $arr, String $out )
    $arr := Array( $type : type, $content : content )
    $out := String() from accumulate (
        $s : String() from utils.tokenize( $content ),
        init( String x = ""; ),
        action( x = ( "".equals(x) ? ", " : "" ) + utils.format( $type, $s ) + x; ),
        result( x )
    )
end







  //******************************************************************************************************************
  //     MiningSchema
  //
  //******************************************************************************************************************







rule "Preprocess_Inputs"
dialect "mvel"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs, usageType == FIELDUSAGETYPE.ACTIVE )
then
    //System.err.println("Found Mined Field " + $fld.name );
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "model", utils.context );
    applyTemplate( "miningField.drlt", utils, registry, map, theory );
end

rule "Create IO Trait"
dialect "mvel"
salience -10
when
    MiningSchema( $miningFields : miningFields )
    accumulate( $mf : MiningField( usageType == FIELDUSAGETYPE.ACTIVE ) from $miningFields, $expNum : count( $mf ) )
    $fields : java.util.Map( size == $expNum ) from accumulate (
            MiningField( this memberOf $miningFields, $name : name, usageType == FIELDUSAGETYPE.ACTIVE ) from $miningFields
            and
            TypeOfField( $n : name == $name, $type : dataType )
         ,
        init( java.util.Map map = new java.util.LinkedHashMap(); ),
        action( map.put( utils.compactUpperCase( $n ), $type ); ),
        result( map )
    )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fields", $fields );
    applyTemplate( "ioTrait.drlt", utils, registry, map, theory );
end


rule "Preprocess_Inputs_InvalidsAsInvalid"
dialect "mvel"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs, usageType == FIELDUSAGETYPE.ACTIVE, invalidValueTreatment == INVALIDVALUETREATMENTMETHOD.RETURN_INVALID )
then
    //TODO : Do not eval, but return invalid !
end


rule "Preprocess_Inputs_InvalidsAsMissing"
dialect "java"
when
    MiningSchema(  $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        invalidValueTreatment == INVALIDVALUETREATMENTMETHOD.AS_MISSING, $val : missingValueReplacement )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "replacement", utils.format( utils.mapDatatype( $type ), $val ) );
    applyTemplate( "miningFieldInvalid.drlt", utils, registry, map, theory );
end






rule "Preprocess_Inputs_MissingReplacement"
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        $val : missingValueReplacement != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "replacement", utils.format( utils.mapDatatype( $type ), $val ) );
    applyTemplate( "miningFieldMissing.drlt", utils, registry, map, theory );
end




rule "Preprocess_Inputs_OutliersAsMissing" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        outliers == OUTLIERTREATMENTMETHOD.AS_MISSING_VALUES,
                        $low : lowValue, $upp : highValue )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "upp", utils.format( utils.mapDatatype( $type ), $upp ) );
        map.put( "low", utils.format( utils.mapDatatype( $type ), $low ) );
    applyTemplate( "miningFieldOutlierAsMissing.drlt", utils, registry, map, theory );
end


rule "Preprocess_Inputs_OutliersAsExtremeLow" //numeric only
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        $vaal : outliers == OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES,
                        //avoid mysterious reason why I can't use == "asExtremeValues" in the line above !?!?!
//                        $vaal.equals( "asExtremeValues" ),
                        $low : lowValue != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "low", utils.format( utils.mapDatatype( $type ), $low ) );
    applyTemplate( "miningFieldOutlierAsExtremeLow.drlt", utils, registry, map, theory );
end


rule "Preprocess_Inputs_OutliersAsExtremeUpp" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        $vaal : outliers == OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES,
                        //avoid mysterious reason why I can't use == "asExtremeValues" in the line above !?!?!
//                        $vaal.equals( "asExtremeValues" ),
                        $upp : highValue != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "upp", utils.format( utils.mapDatatype( $type ), $upp ) );
    applyTemplate( "miningFieldOutlierAsExtremeUpp.drlt", utils, registry, map, theory );
end


rule "BuildQuery"
when
    // can't use assertBehaviour.EQUALITY because of poorly formed PMML Descr
    $q: QueryMarker( $name : name, $context : context)
    not QueryMarker( this != $q, name == $name, context == $context )
then
    HashMap map = new HashMap( 7 );
             map.put( "model", $context );
             map.put( "field", $name);
    applyTemplate( "neuralOutputQuery.drlt", utils, registry, map, theory );
end

  //******************************************************************************************************************
    //    Targets
    //
    //******************************************************************************************************************


 rule "Generic_Target"
 when
    $t: Target( $field : field, targetValues.size() == 0,
                 $cast : castInteger, $max : max, $min : min, $offset : rescaleConstant, $scale : rescaleFactor  )
    MiningField( name == $field, usageType == FIELDUSAGETYPE.PREDICTED )
 then
     HashMap map = new HashMap( 7 );
         map.put( "model", utils.context );
         map.put( "field", utils.compactUpperCase( $field ) );
         map.put( "cast", $cast );
         map.put( "min", $min );
         map.put( "max", $max );
         map.put( "offset", $offset );
         map.put( "scale", $scale );
     applyTemplate( "targetReshape.drlt", utils, registry, map, theory );
 end


 //******************************************************************************************************************
     //    Outputs
     //
     //******************************************************************************************************************




rule "Output_Type"
when
     $of : OutputField( $name : name, $dataType : dataType != null )
then

    insertLogical( new TypeOfField( $name, $dataType ) );
end

rule "Output_Type2"
no-loop
when
    $of : OutputField( $name : name, dataType == null, $tgt : targetField )
    TypeOfField( name == $tgt, $dataType : dataType )
then
    insertLogical( new TypeOfField( $name, $dataType ) );
end




rule "DeclareOutput_Neural"
dialect "mvel"
salience 1
when
    $of  : OutputField( $name : name, $tgt : targetField )
    $tf  : TypeOfField( name == $name )
    $mod : OutputParentModel( field == $of, $mt : modelType )
    eval(! utils.isModelBeanDefined( utils.compactUpperCase( $name ) ) )
then
    utils.addModelBeanDefinition( $name );
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fullName", $of.displayName );
        map.put( "name", utils.compactUpperCase( $of.name ) );
        map.put( "super", "OutputField" );
        map.put( "modelType", $mt )
        map.put( "type", utils.mapDatatype( $tf.dataType ) );
    applyTemplate( "ioTypeDeclare.drlt", utils, registry, map, theory );
    applyTemplate( "updateIOField.drlt", utils, registry, map, theory );
end

rule "Output_Expose"
when
    $of : OutputField( $name : name )
then
    insert( new QueryMarker( utils.compactUpperCase( $name ), utils.context ) );
end




rule "SimpleValueOutput"
dialect "mvel"
when
    $of : OutputField( $tgt : targetField, $val : value, $name : name, feature == null || feature == RESULTFEATURE.PREDICTED_VALUE )
    $tf : TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "origField", utils.compactUpperCase( $tgt ) );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "value", $val );
        map.put( "type", $type );
    applyTemplate( "aliasedOutput.drlt", utils, registry, map, theory );
end





rule "AddFeature_DisplayValue"
dialect "mvel"
when
    $of : OutputField( $tgt : targetField, $val : value, $name : name,
                       feature == RESULTFEATURE.PREDICTED_DISPLAY_VALUE )
    $tf : TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "origField", utils.compactUpperCase( $tgt ) );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "value", $val );
        map.put( "type", $type );
        map.put( "feature", "displayValue" );
    applyTemplate( "addOutputFeature.drlt", utils, registry, map, theory );
end







  //******************************************************************************************************************
  //     NeuralNetwork
  //
  //******************************************************************************************************************





rule "setupNNs"
when
   NeuralNetwork( $name : modelName )
   $stat : ModelStat( neuralNetwork == false )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "type","NeuralNetwork" );
    applyTemplate( "modelMark.drlt", null, registry, map, theory );

    applyTemplate( "neuralBeans.drlt", null, registry, null, theory );

    applyTemplate( "neuralLinkSynapses.drlt", null, registry, null, theory );

    modify ( $stat ) {
        setNeuralNetwork( true );
    }
end



rule "visitNeuralNetwork_context"
salience -9
when
    $net : NeuralNetwork( $name : modelName )
then
    utils.context = utils.compactUpperCase( $name );
end


rule "Neural_InputFieldGeneration"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName )
    NeuralInputs( this memberOf $info, $nis : neuralInputs )
    $ni : NeuralInput( this memberOf $nis, $fld : derivedField, $id : id )
then
    String name = utils.compactUpperCase( $nn ) + "_" + $id;
    $fld.setName( name );
    insertLogical( $fld );

    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( name ) );
        map.put( "context", utils.context );
        map.put( "index", $id );
    applyTemplate( "neuralWireInput.drlt", utils, registry, map, theory );
end


rule "Neural_DerivedInputFieldOverride"
dialect "mvel"
when
    NeuralInput( derivedField != null, $fld : derivedField.name != null )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $fld ) );
        map.put( "context", utils.context );
    applyTemplate( "updateIOField.drlt", utils, registry, map, theory );
end

rule "Neural_RefInputFieldOverride"
dialect "mvel"
when
    NeuralInput( derivedField != null, $fld :derivedField.fieldRef != null )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $fld.field ) );
        map.put( "context", utils.context);
    applyTemplate( "updateIOField.drlt", utils, registry, map, theory );
end




rule "SetDefaultActivation"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs, $act : activationFunction )
    $nl : NeuralLayer( this memberOf $info, activationFunction == null )
then
    modify ( $nl ) {
        setActivationFunction( $act );
    }
end

rule "SetDefaultThreshold"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs, $thold : threshold )
    $nl : NeuralLayer( this memberOf $info, threshold == null )
then
    modify ( $nl ) {
        setThreshold( $thold );
    }
end


rule "SetDefaultBias"
salience 100
when
    $n : Neuron( bias == null )
then
    modify ( $n ) {
        setBias( 0.0 );
    }
end


rule "SetDefaultNormalization"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs,
                    $norm : normalizationMethod != null && normalizationMethod != NNNORMALIZATIONMETHOD.NONE )
    $nl : NeuralLayer( this memberOf $info, normalizationMethod == null)
then
    modify ( $nl ) {
        setNormalizationMethod( $norm );
    }
end

rule "Synapses"
salience -10
when
    $n : Neuron( $links : cons, $index : id )
then
    HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "index", $index );
        map.put( "links", $links );
    applyTemplate( "neuralBuildSynapses.drlt", utils, registry, map, theory );
end


rule "Neuron"
salience -9
when
    NeuralLayer( $ns : neurons, $act : activationFunction != null, $thold : threshold != null, $norm : normalizationMethod )
    $n : Neuron( this memberOf $ns, $index : id, $bias : bias != null, $in : cons )
then
    //System.err.println("CREATE NEURON RULE FOR " + $index + " >> " + $act + "  " + $bias + "  " + $thold);

     HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "index", $index );
        map.put( "actFun", $act );
        map.put( "needsNormal", $norm != null );
        map.put( "bias", $bias );
        map.put( "thold", $thold );
        map.put( "inLink", $in.size() );
    applyTemplate( "neuralFire.drlt", utils, registry, map, theory );
end


rule "Neural_Layer_Max_Normalization"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName )
    $nl : NeuralLayer( this memberOf $info, $ns : neurons,
                 normalizationMethod != null && normalizationMethod == NNNORMALIZATIONMETHOD.SIMPLEMAX )
then
    HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "neurons", $ns );
        map.put( "j", utils.nextCount() );
    applyTemplate( "neuralLayerMaxNormalization.drlt", utils, registry, map, theory );
end


rule "Neural_Layer_Max_SoftNormalization"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName )
    $nl : NeuralLayer( this memberOf $info, $ns : neurons,
                 normalizationMethod != null && normalizationMethod == NNNORMALIZATIONMETHOD.SOFTMAX )
then
    HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "neurons", $ns );
        map.put( "j", utils.nextCount() );
    applyTemplate( "neuralLayerSoftMaxNormalization.drlt", utils, registry, map, theory );
end



rule "Neural_Output_Field_Def"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName )
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
then
    String name = utils.compactUpperCase($nn)+"_"+$id;

    HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "name", name );
        map.put( "index", $id );
    applyTemplate( "neuralOutputField.drlt", utils, registry, map, theory );

    map = new HashMap();
        map.put( "context", utils.context );
        map.put( "fullName", name );
        map.put( "name", name );
        map.put( "super", null );
        map.put( "type", utils.mapDatatype( DATATYPE.DOUBLE ) );
        map.put( "cyclic", false );
        map.put( "categorical", false );
        map.put( "continuous", true );
        map.put( "ordinal", false );
        map.put( "modelType", null );
    applyTemplate( "ioTypeDeclare.drlt", utils, registry, map, theory );
    applyTemplate( "updateIOField.drlt", utils, registry, map, theory );
end

/*
 rule "Neural_Output_Expose"
 salience -9
 when
     NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
     NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
     $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
 then
     String name = utils.compactUpperCase($nn)+"_"+$id;
     insert( new QueryMarker(name,utils.context) );

     HashMap map = new HashMap(7);
         map.put("name",name);
     applyTemplate("confirm.drlt", utils, registry, map, theory);
 end
*/



rule "Neural_Output_Invert_NormContinuous"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName, functionName == MININGFUNCTION.REGRESSION )
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df  : DerivedField( $norm : normContinuous != null ) from $fld
    NormContinuous( $mmt : mapMissingTo, $field : field, $outl : outliers, $ls : linearNorms ) from $norm
then

    //insert( new QueryMarker(utils.compactUpperCase($field),utils.context) );

    NormContinuous invertedNC = new NormContinuous();
        invertedNC.setMapMissingTo( $mmt );
        invertedNC.setField( utils.compactUpperCase( $nn ) + "_" + $id );
        invertedNC.setOutliers( $outl );
        for ( int j = 0; j < $ls.size(); j++ ) {
            LinearNorm orig = (LinearNorm) $ls.get( j );
            LinearNorm inv = new LinearNorm();
                inv.setNorm( orig.getOrig() );
                inv.setOrig( orig.getNorm() );
            invertedNC.getLinearNorms().add( inv );
        }

//    HashMap map = new HashMap(7);
//        map.put("name",utils.compactUpperCase($field));
//    applyTemplate("confirm.drlt", utils, registry, map, theory);

    $df.setName( $field );
    $df.setNormContinuous( invertedNC );

    insertLogical( $df );
    insertLogical( invertedNC );
end




rule "Neural_Output_Invert_NormDiscrete_asPredicate"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName, functionName == MININGFUNCTION.CLASSIFICATION )
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df  : DerivedField( $norm : normDiscrete != null) from $fld
    NormDiscrete( $field : field, $val : value ) from $norm
    TypeOfField( name == $field, $type : dataType )
then
    HashMap map = new HashMap(7);
        map.put( "model", utils.context );
        map.put( "field", utils.compactUpperCase($field) );
        map.put( "label", $val );
        map.put( "target", utils.format($type,utils.compactUpperCase( $val ) ) );
    applyTemplate( "neuralOutputQueryPredicate.drlt", utils, registry, map, theory );

    map = new HashMap();
        map.put( "name", utils.compactUpperCase( $field ) );
        map.put( "model", utils.context );
        map.put( "target", utils.format( $type, $val ) );
        map.put( "origField", utils.compactUpperCase( $nn )+"_"+$id );
    applyTemplate( "predicateField.drlt", utils, registry, map, theory );
end



rule "Neural_Output_Invert_FieldRef"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df  : DerivedField( $ref : fieldRef != null ) from $fld
    FieldRef( $field : field ) from $ref
then

    //insert( new QueryMarker(utils.compactUpperCase($field),utils.context) );

    $df.setName( $field );
    $ref.setField( utils.compactUpperCase( $nn ) + "_" + $id );

    insertLogical( $ref );
    insertLogical( $fld );
end


rule "Clean_WM"
salience -19
dialect "mvel"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName )
    $ms : MiningSchema( this memberOf $info, $fields : miningFields )
then
    HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "fields", $fields );
    applyTemplate( "neuralClean.drlt", utils, registry, map, theory );
end


rule "Clean_WM_Pre"
salience -18
dialect "mvel"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName )
    $ms :  MiningSchema( this memberOf $info, $fields : miningFields )
    $fld : MiningField( usageType != null &&
                        ( usageType == FIELDUSAGETYPE.PREDICTED || usageType == FIELDUSAGETYPE.SUPPLEMENTARY )
           ) from $fields
then
    $fields.remove( $fld );
end



rule "Neural_Cleanup"
salience -20
when
    $nn : NeuralNetwork( )
then
    utils.context = null;
    retract( $nn );
end









  //******************************************************************************************************************
  //     Tree
  //
  //******************************************************************************************************************



rule "TreeRoot"
when
    $tree : TreeModel()
then
    applyTemplate( "treeDeclare.drlt", utils, registry, null, theory );
end


rule "visitTree_context"
salience -9
when
    $tree : TreeModel( $name : modelName )
then
    utils.context = utils.compactUpperCase( $name );

    HashMap map = new HashMap( 3 );
        map.put( "name", utils.context );
        map.put( "type","DecisionTree" );
    applyTemplate( "modelMark.drlt", null, registry, map, theory );
end

query treeParent( Node $n, Node $par )
    $n   := Node()
    $par := Node( nodes contains $n )
end


rule "Tree Common Rules"
salience -9
when
    $tree : TreeModel( $name : modelName, $info : extensionsAndNodesAndMiningSchemas )
    MiningSchema( this memberOf $info, $mfs : miningFields )
    MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $tgtName : name )
then
    HashMap map = new HashMap( 3 );
        map.put( "model", utils.context );
        map.put( "name", utils.compactUpperCase( $tgtName ) );
    applyTemplate( "treeCommon.drlt", utils, registry, map, theory );
end

rule "Init tree nodes"
salience -10
when
    $net : TreeModel( $info : extensionsAndNodesAndMiningSchemas )
    accumulate ( $n : Node( ),
                 $nodes : collectList( $n );
                 $nodes.size() > 0
               )
    $parents : java.util.Map() from accumulate (
                 $n : Node( $nid : id ) and treeParent( $n, $par ; ),
                 init( java.util.Map m = new java.util.HashMap(); ),
                 action( m.put( $nid, $par.getId() ); ),
                 result( m )
               )
    $totals  : java.util.Map() from accumulate (
                 $n : Node( $nid : id, $tot : recordCount ),
                 init( java.util.Map m = new java.util.HashMap(); ),
                 action( m.put( $nid, $tot != null ? $tot.intValue() : 0 ); ),
                 result( m )
               )
    $counts  : java.util.Map() from accumulate (
                 $n : Node( $nid : id, $scores : scoreDistributions )
                 and
                 $rcounts : java.util.Map() from accumulate (
                    ScoreDistribution( $val : value, $num : recordCount ) from $scores,
                    init( java.util.Map n = new java.util.HashMap(); ),
                    action( n.put( $val, $num ); ),
                    result( n )
                 ),
                 init( java.util.Map m = new java.util.HashMap(); ),
                 action( m.put( $nid, $rcounts ); ),
                 result( m )
               )
    $confs   : java.util.Map() from accumulate (
                 $n : Node( $nid : id, $scores : scoreDistributions )
                 and
                 $ccounts : java.util.Map() from accumulate (
                    ScoreDistribution( $val : value, $num : confidence ) from $scores,
                    init( java.util.Map n = new java.util.HashMap(); ),
                    action( n.put( $val, $num ); ),
                    result( n )
                 ),
                 init( java.util.Map m = new java.util.HashMap(); ),
                 action( m.put( $nid, $ccounts ); ),
                 result( m )
               )
    MiningSchema( this memberOf $info, $mfs : miningFields )
    MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $name : name )
    TypeOfField( name == $name, $type : dataType )
then
    java.util.List orderedNodeList = new java.util.ArrayList( $nodes );
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "tgtType", $type );
        map.put( "parents", $parents );
        map.put( "nodes", $nodes );
        map.put( "totals", $totals );
        map.put( "counts", $counts );
        map.put( "confs", $confs );
    applyTemplate( "treeInit.drlt", utils, registry, map, theory );
end


rule "Declare tree input"
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas, $miss : missingValueStrategy )
    MiningSchema( $miningFields : miningFields, this memberOf $info )
    accumulate( $mf : MiningField( usageType == FIELDUSAGETYPE.ACTIVE ) from $miningFields, $expNum : count( $mf ) )
    $fields : java.util.Map( size == $expNum ) from accumulate (
            MiningField( this memberOf $miningFields, $name : name, usageType == FIELDUSAGETYPE.ACTIVE ) from $miningFields
            and
            TypeOfField( $n : name == $name, $type : dataType )
         ,
        init( java.util.Map map = new java.util.LinkedHashMap(); ),
        action( map.put( utils.compactUpperCase( $n ), $type ); ),
        result( map )
    )
    $root : Node( $rid : id, this memberOf $info)
    MiningField( this memberOf $miningFields, usageType == FIELDUSAGETYPE.PREDICTED, $tgtName : name )
    TypeOfField( name == $tgtName, $tgtType : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fields", $fields );
        map.put( "rootId", $rid );
        map.put( "visitMode", $miss );
        map.put( "targetField", utils.compactUpperCase( $tgtName ) );
        map.put( "targetType", $tgtType );
    applyTemplate( "treeInputDeclare.drlt", utils, registry, map, theory );
    applyTemplate( "treeIOBinding.drlt", utils, registry, map, theory );
end



query compilePredicateForMissing( java.util.List $parent, String $pred, Object $src )
    (
      $src  := SimplePredicate( this memberOf $parent, $fld := field, $op : operator, $val : value )
      and
      $pred := String() from "( " + "m" + utils.compactUpperCase( $fld ) + " == true " + " )"
    )
    or
    (
      $src  := SimpleSetPredicate( this memberOf $parent, $fld := field )
      and
      $pred := String() from "( " + "m" + utils.compactUpperCase( $fld ) + " == true " + " )"
    )
    or
    ( $src  := True( this memberOf $parent ) and $pred := String() from "false" )
    or
    ( $src  := False( this memberOf $parent ) and $pred := String() from "false" )
//    or
//    ( $src  := CompoundPredicate( this memberOf $parent, booleanOperator == "surrogate" ) and $pred := String() from "false" )
    or
    ( (
        $src  := CompoundPredicate( this memberOf $parent, $sub : simplePredicatesAndCompoundPredicatesAndSimpleSetPredicates )
        and
        $pred := String() from accumulate( compilePredicateForMissing( $sub, $p, $fld2 ; ),
                                           init( String x = "" ),
                                           action( x = "( " + $p + " )"
                                                       + ( "".equals(x) ? "" : " || " )
                                                       + x; ),
                                           result( x )
                                         )
    ) )
end


query compilePredicate( java.util.List $parent, String $pred, Object $src )
    (
      $src  := SimplePredicate( this memberOf $parent, $fld := field, $op : operator, $val : value )
      and
      TypeOfField( $fld, $type ; )
      and
      $pred := String() from "( " +
                                "m" + utils.compactUpperCase( $fld ) + " == false && " +
                                "v" + utils.compactUpperCase( $fld ) + " " + utils.mapOperator( $op ) + " " + utils.format( $type, $val ) +
                             " )"
    )
    or
    (
      $src  := SimpleSetPredicate( this memberOf $parent, $fld := field, $op : booleanOperator, $arr : array )
      and
      formatArray( $arr, $out ; )
      and
      $pred := String() from "( " + "m" + utils.compactUpperCase( $fld ) + " == false && " +
                                    "v" + utils.compactUpperCase( $fld ) + ( "isNotIn".equals( $op ) ? " not" : "" ) + " in ( " + $out + " ) )"
    )
    or
    ( $src  := True( this memberOf $parent ) and $pred := String() from "1 == 1" )
    or
    ( $src  := False( this memberOf $parent ) and $pred := String() from "1 == 0" )
    or
    ( (
        $src  := CompoundPredicate( this memberOf $parent, $sub : simplePredicatesAndCompoundPredicatesAndSimpleSetPredicates, booleanOperator != "surrogate")
        and
        $pred := String() from accumulate( CompoundPredicate( this == $src, $bop : booleanOperator )
                                           and
                                           compilePredicate( $sub, $p, $fld2 ; ),
                                           init( String x = "" ),
                                           action( x = "( " + $p + " )"
                                                       + ( "".equals(x) ? "" : utils.mapTreeOp( $bop ) )
                                                       + x; ),
                                           result( x )
                                         )
    ) )
    or
    ( (
        $src  := CompoundPredicate( this memberOf $parent, $sub : simplePredicatesAndCompoundPredicatesAndSimpleSetPredicates, booleanOperator == "surrogate" )
        and
        $pred := String() from accumulate( compilePredicate( $sub, $p, $xx ; )
                                           and
                                           ?compilePredicateForMissing( $sub, $m, $xx ; ),
                                           init( String x = ""; String m = "true"; boolean first = true; ),
                                           action(
                                                   x = $p
                                                       + ( first ? "" : " || "
                                                       + "( " + m + " && ( " + x + " ) )" );
                                                   m = $m;
                                                   first = false;
                                           ),
                                           result( x )
                                         )
    ) )
end

query treeNode( java.util.Collection $cll, String $id )
    Node( $id := id, this memberOf $cll )
    or
    (
        Node( this memberOf $cll, $children : nodes )
        and
        treeNode( $children, $id ; )
    )
end

rule "Node Evaluation"
salience -13
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas, $penalty : missingValuePenalty, $missStrat : missingValueStrategy )
    Node( $id : id, $coll : extensionsAndSimplePredicatesAndCompoundPredicates )
    ?treeNode( $info, $id ; )
    compilePredicate( $coll, $pred, $src ; )
    ?compilePredicateForMissing( $coll, $miss, $src ; )
    MiningSchema( this memberOf $info, $fields : miningFields )
    MiningField( usageType != null && == FIELDUSAGETYPE.PREDICTED, $tgt : name )
    TypeOfField( name == $tgt, $tgtType : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "id", $id );
        map.put( "constraints", $pred );
        map.put( "missings", $miss );
        map.put( "penalty", $penalty != null ? $penalty : 1.0 );
        map.put( "name", utils.compactUpperCase( $tgt ) );
        map.put( "tgtType", $tgtType );
    applyTemplate( "treeEval.drlt", utils, registry, map, theory );

    if ( $missStrat.equals( MISSINGVALUESTRATEGY.AGGREGATE_NODES ) ) {
        applyTemplate( "treeAggregateEval.drlt", utils, registry, map, theory );
    }

    if ( $missStrat.equals( MISSINGVALUESTRATEGY.DEFAULT_CHILD ) ) {
        applyTemplate( "treeDefaultEval.drlt", utils, registry, map, theory );
    }

end



rule "Missing Handler Aggregate Strategy"
salience -13
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas, missingValueStrategy == MISSINGVALUESTRATEGY.AGGREGATE_NODES )
    MiningSchema( this memberOf $info, $fields : miningFields )
    MiningField( usageType != null && == FIELDUSAGETYPE.PREDICTED, $tgt : name )
    TypeOfField( name == $tgt, $tgtType : dataType )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $tgt ) );
        map.put( "tgtType", $tgtType );
    applyTemplate( "treeMissHandleAggregate.drlt", utils, registry, map, theory );
end


rule "Missing Handler Weighted Strategy"
salience -13
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas, missingValueStrategy == MISSINGVALUESTRATEGY.WEIGHTED_CONFIDENCE )
    MiningSchema( this memberOf $info, $fields : miningFields )
    MiningField( usageType != null && == FIELDUSAGETYPE.PREDICTED, $tgt : name )
    TypeOfField( name == $tgt, $tgtType : dataType )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $tgt ) );
        map.put( "tgtType", $tgtType );
    applyTemplate( "treeMissHandleWeighted.drlt", utils, registry, map, theory );
end

rule "Missing Handler Last Prediction Strategy"
salience -13
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas, missingValueStrategy == MISSINGVALUESTRATEGY.LAST_PREDICTION )
    MiningSchema( this memberOf $info, $fields : miningFields )
    MiningField( usageType != null && == FIELDUSAGETYPE.PREDICTED, $tgt : name )
    TypeOfField( name == $tgt, $tgtType : dataType )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $tgt ) );
        map.put( "tgtType", $tgtType );
    applyTemplate( "treeMissHandleLast.drlt", utils, registry, map, theory );
end

rule "Missing Handler Null Strategy"
salience -13
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas, missingValueStrategy == MISSINGVALUESTRATEGY.NULL_PREDICTION )
    MiningSchema( this memberOf $info, $fields : miningFields )
    MiningField( usageType != null && == FIELDUSAGETYPE.PREDICTED, $tgt : name )
    TypeOfField( name == $tgt, $tgtType : dataType )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $tgt ) );
        map.put( "tgtType", $tgtType );
    applyTemplate( "treeMissHandleNull.drlt", utils, registry, map, theory );
end


rule "Missing Handler None Strategy"
salience -13
when
    TreeModel( $info : extensionsAndNodesAndMiningSchemas,
                       missingValueStrategy == MISSINGVALUESTRATEGY.NONE, noTrueChildStrategy == NOTRUECHILDSTRATEGY.RETURN_LAST_PREDICTION )
    MiningSchema( this memberOf $info, $fields : miningFields )
    MiningField( usageType != null && == FIELDUSAGETYPE.PREDICTED, $tgt : name )
    TypeOfField( name == $tgt, $tgtType : dataType )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $tgt ) );
        map.put( "tgtType", $tgtType );
    applyTemplate( "treeMissHandleNone.drlt", utils, registry, map, theory );
end



rule "TreeNodes need an ID!"
when
    $tree : TreeModel( $name : modelName )
    $node : Node( id == null )
then
    modify ( $node ) { setId( $name + utils.nextCount() ); }
end

rule "Tree_Cleanup"
salience -20
when
    $tri : TreeModel( )
then
    utils.context = null;
    retract( $tri );
end





  //******************************************************************************************************************
  //     SVM
  //
  //******************************************************************************************************************




rule "SVMRoot"
when
    $svm : SupportVectorMachineModel()
then
    applyTemplate( "svmDeclare.drlt", utils, registry, null, theory );
    applyTemplate( "svmFunctions.drlt", utils, registry, null, theory );
end

rule "visitSVM_context"
salience -9
when
    $svm : SupportVectorMachineModel( $name : modelName )
then
    utils.context = utils.compactUpperCase( $name );

    HashMap map = new HashMap( 3 );
        map.put( "name", utils.context );
        map.put( "type","SupportVectorMachine" );
    applyTemplate( "modelMark.drlt", null, registry, map, theory );
end


rule "visitSVM_SVM_Params"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $svm  : SupportVectorMachine( this memberOf $info,
                                  $bias : coefficients.absoluteValue,
                                  $noc : coefficients.numberOfCoefficients,
                                  $nos : supportVectors.numberOfSupportVectors,
                                  $coeffs : coefficients, $svs : supportVectors,
                                  $target : targetCategory, $alt : alternateTargetCategory )
    $dic : VectorDictionary( this memberOf $info, $vlist : vectorInstances )
    accumulate( Coefficient( $val : value, this memberOf $coeffs.coefficients ),
                $cx : collectList( $val );
                $cx.size == $noc )
    accumulate( SupportVectorReference( $index : index, supportVector memberOf $svs.supportVectors ),
                $ix : collectList ( $index ),
                $mX : max( $index );
                $ix.size == $nos )
then
    HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "svmId", utils.context + $info.indexOf( $svm ) );
            map.put( "absoluteValue", $bias );
            map.put( "indexes", $ix );
            map.put( "maxIndex", $mX.intValue() );
            map.put( "coeffs", $cx );
            map.put( "target", $target );
            map.put( "alt", $alt );
    applyTemplate( "svmBuild.drlt", utils, registry, map, theory );
end



declare SupportVectorReference
    vectorInstance : VectorInstance
    supportVector  : SupportVector
    index          : int
    sparse         : boolean
end

rule "Join Support Vectors and Instances"
when
    $sm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $dx : VectorDictionary( this memberOf $info, $vlist : vectorInstances )
    $sv : SupportVector( $vid : vectorId )
    $vi : VectorInstance( id == $vid, this memberOf $vlist )
then
    insertLogical( new SupportVectorReference( $vi, $sv, $vlist.indexOf ( $vi ), $vi.getREALSparseArray() != null ) );
end

rule "SVM_InitSupportVectors"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $ved  : VectorDictionary( this memberOf $info,
                              $nos : numberOfVectors,
                              $nat : vectorFields.numberOfFields )
    accumulate( $svr : SupportVectorReference( $index : index ),
                $ix : collectList ( $svr ) )
then
    HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "size", $nat.intValue() );
            map.put( "vectors", $ix );
    applyTemplate( "svmInitSupportVector.drlt", utils, registry, map, theory );
end



rule "SVM_InputVector"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries  )
    $vd   : VectorDictionary( this memberOf $info, $flds : vectorFields.fieldReves )
then
    HashMap map = new HashMap(3);
            map.put( "modelName", utils.context );
            map.put( "inputVectors", $flds );
    applyTemplate( "svmInitInputVector.drlt", utils, registry, map, theory );
end



rule "SVM_KernelEvals_RBF"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $rbkt : RadialBasisKernelType ( this memberOf $info, $gamma : gamma )
then
    HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "kernelType", "rbf" );
    applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
            map.put( "gamma", $gamma );
            map.put( "coef0", 0.0 );
            map.put( "degree", 0.0 );
    applyTemplate( "svmParams.drlt", utils, registry, map, theory );
end

rule "SVM_KernelEvals_POLY"
   salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $pkt : PolynomialKernelType ( this memberOf $info, $gamma : gamma, $coef0 : coef0, $degree : degree )
then
    HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "kernelType", "poly" );
    applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
            map.put( "gamma", $gamma );
            map.put( "coef0", $coef0 );
            map.put( "degree", $degree );
    applyTemplate( "svmParams.drlt", utils, registry, map, theory );
end

rule "SVM_KernelEvals_LINEAR"
salience -16
when
   $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
   $lkt : LinearKernelType ( this memberOf $info )
then
    HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "kernelType", "linear" );
    applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
            map.put( "gamma", 0.0 );
            map.put( "coef0", 0.0 );
            map.put( "degree", 0.0 );
    applyTemplate( "svmParams.drlt", utils, registry, map, theory );
end

rule "SVM_KernelEvals_SIMOID"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $pkt : SigmoidKernelType ( this memberOf $info, $gamma : gamma, $coef0 : coef0)
then
    HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "kernelType", "sigmoid" );
    applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
            map.put( "gamma", $gamma );
            map.put( "coef0", $coef0 );
            map.put( "degree", 0.0 );
    applyTemplate( "svmParams.drlt", utils, registry, map, theory );
end








rule "SVM_Output_Gen"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries, $baseThold : threshold, $cm : classificationMethod )
            // if only 1 svm is present, no voting is required
            accumulate( SupportVectorMachine( this memberOf $info ), $num : count(1) )
    $svm  : SupportVectorMachine( this memberOf $info, $localThold : threshold,
                                  $posCat : targetCategory, $altCat : alternateTargetCategory
                                )
            MiningSchema( this memberOf $info, $mfs : miningFields )
            MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $name : name )
            TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
            map.put( "context", utils.context );
            map.put( "svmId", utils.context + $info.indexOf( $svm ) );
            map.put( "target", utils.compactUpperCase( $name ) );
            map.put( "type", $type );
            map.put( "simple", $num.intValue() == 1 );
            map.put( "oneVSmany", $cm.equals( SVMCLASSIFICATIONMETHOD.ONE_AGAINST_ALL ) );
            map.put( "threshold", $baseThold  );
            map.put( "posCat", $posCat );
            map.put( "negCat", $altCat );
    applyTemplate( "svmOutputGeneration.drlt", utils, registry, map, theory );
end


rule "SVM_Output_Votes_Declare"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
            accumulate( SupportVectorMachine( this memberOf $info ), $num : count(1); $num > 1 )
            MiningSchema( this memberOf $info, $mfs : miningFields )
            MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $name : name )
            TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 3 );
            map.put( "context", utils.context );
            map.put( "target", utils.compactUpperCase( $name ) );
            map.put( "type", $type );
    applyTemplate( "svmOutputVoteDeclare.drlt", utils, registry, map, theory );
end

rule "SVM_Output_Votes_1vN"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries, classificationMethod == SVMCLASSIFICATIONMETHOD.ONE_AGAINST_ALL )
            accumulate( SupportVectorMachine( this memberOf $info ), $num : count(1); $num > 1 )
            MiningSchema( this memberOf $info, $mfs : miningFields )
            MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $name : name )
            TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
            map.put( "context", utils.context );
            map.put( "target", utils.compactUpperCase( $name ) );
            map.put( "type", $type );
    applyTemplate( "svmOutputVote1vN.drlt", utils, registry, map, theory );
end

rule "SVM_Output_Votes_1v1"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries, classificationMethod == SVMCLASSIFICATIONMETHOD.ONE_AGAINST_ONE )
            accumulate( SupportVectorMachine( this memberOf $info ), $num : count(1); $num > 1 )
            MiningSchema( this memberOf $info, $mfs : miningFields )
            MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $name : name )
            TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
            map.put( "context", utils.context );
            map.put( "target", utils.compactUpperCase( $name ) );
            map.put( "type", $type );
    applyTemplate( "svmOutputVote1v1.drlt", utils, registry, map, theory );
end



rule "SVM_Cleanup"
salience -20
when
    $svm : SupportVectorMachineModel( )
then
    utils.context = null;
    retract($svm);
end





  //******************************************************************************************************************
  //     REGRESSION MODEL
  //
  //******************************************************************************************************************




rule "Regression Root"
when
    $reg : RegressionModel()
then
    applyTemplate( "regDeclare.drlt", utils, registry, null, theory );
end

rule "visitRegression_context"
salience -9
when
    $reg : RegressionModel( $name : modelName )
then
    utils.context = utils.compactUpperCase( $name );

    HashMap map = new HashMap( 3 );
        map.put( "name", utils.context );
        map.put( "type","SimpleRegression" );
    applyTemplate( "modelMark.drlt", null, registry, map, theory );
end



rule "Regression Table"
salience -15
when
    $reg : RegressionModel( $regTables : extensionsAndRegressionTablesAndMiningSchemas )
    $tab : RegressionTable( this memberOf $regTables,
                            $c0 : intercept, $tgtCat : targetCategory, $num : numericPredictors, $cat : categoricalPredictors, $trm : predictorTerms )
    accumulate( NumericPredictor( this memberOf $num, $c : coefficient, $e : exponent ), $numC : collectList( $c ), $numE : collectList( $e.doubleValue() ) )
    accumulate( CategoricalPredictor( this memberOf $cat, $c : coefficient ), $catC : collectList( $c ) )
    accumulate( PredictorTerm( this memberOf $trm, $c : coefficient ), $trmC : collectList( $c ) )
           MiningSchema( $mfs : miningFields, this memberOf $regTables )
           MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $tgt : name )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "c0", $c0 );
        map.put( "numCoeffs", $numC );
        map.put( "catCoeffs", $catC );
        map.put( "trmCoeffs", $trmC );
        map.put( "numExps", $numE );
        map.put( "target", utils.compactUpperCase( $tgt ) );
        map.put( "category", $tgtCat );
        map.put( "index", $regTables.indexOf( $tab ) );
    applyTemplate( "regParams.drlt", utils, registry, map, theory );
end



rule "Regression Table : regression"
salience -15
when
    $reg : RegressionModel( $regTables : extensionsAndRegressionTablesAndMiningSchemas, functionName == MININGFUNCTION.REGRESSION,
                            $norm : normalizationMethod == null
                                                     || == REGRESSIONNORMALIZATIONMETHOD.NONE
                                                     || == REGRESSIONNORMALIZATIONMETHOD.EXP
                                                     || == REGRESSIONNORMALIZATIONMETHOD.SOFTMAX
                                                     || == REGRESSIONNORMALIZATIONMETHOD.LOGIT )
    $tab : RegressionTable( this memberOf $regTables, $c0 : intercept, $cat : targetCategory,
                            $nps : numericPredictors, $cps : categoricalPredictors, $tps : predictorTerms )
           accumulate( $np : NumericPredictor( this memberOf $nps ), $numPs : collectList( $np ) )
           accumulate( $cp : CategoricalPredictor( this memberOf $cps ), $catPs : collectList( $cp ) )
           accumulate( $tp : PredictorTerm( this memberOf $tps ), $trmPs : collectList( $tp ) )
           MiningSchema( $mfs : miningFields, this memberOf $regTables )
           accumulate( $mf : MiningField( this memberOf $mfs, usageType != FIELDUSAGETYPE.PREDICTED, $fldName : name ), $flds : collectList( $mf ) )
           MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $tgt : name )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "inputFields", $flds );
        map.put( "numPredictors", $numPs );
        map.put( "catPredictors", $catPs );
        map.put( "trmPredictors", $trmPs );
        map.put( "normalization", $norm );
        map.put( "isRegression", true );
        map.put( "category", $cat );
        map.put( "target", utils.compactUpperCase( $tgt ) );
    applyTemplate( "regEval.drlt", utils, registry, map, theory );
end


rule "Regression Table : classification"
salience -15
when
    $reg : RegressionModel( $regTables : extensionsAndRegressionTablesAndMiningSchemas, functionName == MININGFUNCTION.CLASSIFICATION,
                            $norm : normalizationMethod  )
    $tab : RegressionTable( this memberOf $regTables, $c0 : intercept, $cat : targetCategory,
                            $nps : numericPredictors, $cps : categoricalPredictors, $tps : predictorTerms )
           accumulate( $np : NumericPredictor( this memberOf $nps ), $numPs : collectList( $np ) )
           accumulate( $cp : CategoricalPredictor( this memberOf $cps ), $catPs : collectList( $cp ) )
           accumulate( $tp : PredictorTerm( this memberOf $tps ), $trmPs : collectList( $tp ) )
           MiningSchema( $mfs : miningFields, this memberOf $regTables )
           accumulate( $mf : MiningField( this memberOf $mfs, usageType != FIELDUSAGETYPE.PREDICTED, $fldName : name ), $flds : collectList( $mf ) )
           MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $tgt : name )
           (
             DataField( name == $tgt, $opType : optype )
             or
             DerivedField( name == $tgt, $opType : optype )
           )
then
    HashMap map = new HashMap( 11 );
        map.put( "context", utils.context );
        map.put( "inputFields", $flds );
        map.put( "numPredictors", $numPs );
        map.put( "catPredictors", $catPs );
        map.put( "trmPredictors", $trmPs );
        map.put( "normalization", $norm );
        map.put( "isRegression", false );
        map.put( "isCategorical", OPTYPE.CATEGORICAL.equals( $opType ) );
        map.put( "category", $cat );
        map.put( "target", utils.compactUpperCase( $tgt ) );
    applyTemplate( "regEval.drlt", utils, registry, map, theory );
end

rule "Regression Model Output Reconciliation"
salience -15
when
    $reg : RegressionModel( $regTables : extensionsAndRegressionTablesAndMiningSchemas, functionName == MININGFUNCTION.CLASSIFICATION,
                            $norm : normalizationMethod  )
           accumulate( $rt : RegressionTable( this memberOf $regTables ), $numTabs : count( $rt ) )
           MiningSchema( $mfs : miningFields, this memberOf $regTables )
           MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $tgt : name )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "target", utils.compactUpperCase( $tgt ) );
        map.put( "num", $numTabs );
    applyTemplate( "regClaxOutput.drlt", utils, registry, map, theory );
    applyTemplate( "regNormalization.drlt", utils, registry, map, theory );
end


rule "Regression Model Ordinal Output"
salience -15
when
    $reg : RegressionModel( $regTables : extensionsAndRegressionTablesAndMiningSchemas, functionName == MININGFUNCTION.CLASSIFICATION,
                            $norm : normalizationMethod  )
           accumulate( $rt : RegressionTable( this memberOf $regTables ), $numTabs : count( $rt ) )
           MiningSchema( $mfs : miningFields, this memberOf $regTables )
           MiningField( this memberOf $mfs, usageType == FIELDUSAGETYPE.PREDICTED, $tgt : name )
           (
             DataField( name == $tgt, $opType : optype == OPTYPE.ORDINAL )
             or
             DerivedField( name == $tgt, $opType : optype == OPTYPE.ORDINAL )
           )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "target", utils.compactUpperCase( $tgt ) );
        map.put( "num", $numTabs );
    applyTemplate( "regDecumulation.drlt", utils, registry, map, theory );
end
//


rule "Regression_Cleanup"
salience -20
when
    $reg : RegressionModel( )
then
    utils.context = null;
    retract( $reg );
end





  //******************************************************************************************************************
  //     CLUSTERING MODEL
  //
  //******************************************************************************************************************




rule "Clustering Root"
when
    $reg : ClusteringModel()
then
    applyTemplate( "clusteringDeclare.drlt", utils, registry, null, theory );
end

rule "visitClustering_context"
salience -9
when
    $klu : ClusteringModel( $name : modelName )
then
    utils.context = utils.compactUpperCase( $name );

    HashMap map = new HashMap( 3 );
        map.put( "name", utils.context );
        map.put( "type","Clustering" );
    applyTemplate( "modelMark.drlt", null, registry, map, theory );
end


query extractMissingWeights( java.util.Collection $info, int $num, Object $missingWgts )
    (
      MissingValueWeights( this memberOf $info, $data : array.content )
      and
      $missingWgts := List() from collect ( String() from utils.tokenize( $data ) )
    )
    or
    ( not MissingValueWeights( this memberOf $info )
      and
      $missingWgts := List() from collect ( String() from utils.ones( $num ) )
    )
end

rule "Init Clustering"
salience -17
when
    $klu : ClusteringModel( $info : extensionsAndClustersAndComparisonMeasures,
                            $name : modelName,
                            functionName == MININGFUNCTION.CLUSTERING,
                            modelClass == "centerBased",
                            $numClusters : numberOfClusters.intValue() )
    accumulate( $k : Cluster() from $info,                              //need 'from' to preserve order!
                $clusterList : collectList( $k ),
                $num         : count( $k );
                $num == $numClusters
              )
    accumulate( $kf : ClusteringField( isCenterField == true,
                                       $fw : fieldWeight,
                                       $fs : similarityScale ) from $info,  //need 'from' to preserve order!
                $fieldList   : collectList( $kf ),
                $fieldScopes : collectList( $fs != null ? $fs : 1.0 ),
                $fieldWgts   : collectList( $fw ),
                $numFields   : count( $kf )
              )
    extractMissingWeights( $info, $numFields, $missingWgts ; )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "numClusters", $numClusters );
        map.put( "numFields", $numFields );
        map.put( "fieldWeights", $fieldWgts );
        map.put( "fieldScopes", $fieldScopes );
        map.put( "missingWeights", $missingWgts );
        map.put( "klusters", $clusterList );
    applyTemplate( "clusteringInit.drlt", utils, registry, map, theory );
end

rule "Eval Clustering"
salience -18
when
    $klu : ClusteringModel( $info : extensionsAndClustersAndComparisonMeasures,
                            $name : modelName,
                            functionName == MININGFUNCTION.CLUSTERING,
                            modelClass == "centerBased",
                            $numClusters : numberOfClusters.intValue() )
    $msr : ComparisonMeasure( this memberOf $info, $defCmp : compareFunction, $kind : kind )
    accumulate( $k : Cluster() from $info,                              //need 'from' to preserve order!
                $clusterList : collectList( $k ),
                $num         : count( $k );
                $num == $numClusters
              )
    accumulate( $kf : ClusteringField( isCenterField == true ) from $info,  //need 'from' to preserve order!
                $inputFields : collectList( $kf ),
                $numFields   : count( $kf )
              )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "numClusters", $numClusters );
        map.put( "numFields", $numFields.intValue() );
        map.put( "klusters", $clusterList );
        map.put( "inputFields", $inputFields );
        map.put( "defaultCompareFunction", $defCmp );
        map.put( "msr", $msr );
    if ( $kind.equals( "distance" ) ) {
        applyTemplate( "clusteringEvalDistance.drlt", utils, registry, map, theory );
    } else {
        applyTemplate( "clusteringEvalSimilarity.drlt", utils, registry, map, theory );
    }
end



rule "Clustering Map Comparison"
salience -15
when
    $klu : ClusteringModel( $info : extensionsAndClustersAndComparisonMeasures,
                            $name : modelName,
                            functionName == MININGFUNCTION.CLUSTERING,
                            modelClass == "centerBased",
                            $numClusters : numberOfClusters.intValue() )
    $kf : ClusteringField( $fld : field, $cmp : comparisons != null )  //need 'from' to preserve order!
    $db : DoubleMatrix( src == $cmp.matrix )
then
    HashMap map = new HashMap( 3 );
        map.put( "context", utils.context );
        map.put( "fieldName", $fld );
        map.put( "matrix", $db );
    applyTemplate( "clusteringMatrixCompare.drlt", utils, registry, map, theory );
end




rule "Clustering_Cleanup"
salience -20
when
    $klu : ClusteringModel( )
then
    utils.context = null;
    retract( $klu );
end











//**********************************************************************************************************
//
//  INTEGRITY RULES
//
//**********************************************************************************************************


rule "checkDataDictionary"
when
    DataDictionary( $exp : numberOfFields != null, $act : dataFields.size() != $exp )
then
   System.err.println("TODO WARNING : Expected number of fields in DataDictionary different from actual : " + $exp + " vs " + $act );
end





rule "CleanOnFinish_DataField"
salience -9999
when
    $df : DataField()
    not PMML()
then
    retract( $df );
end

rule "CleanOnFinish_ModelStat"
salience -9999
when
    $ms : ModelStat()
    not PMML()
then
    retract( $ms );
end

rule "CleanOnFinish_Qry"
salience -9999
when
    $qm : QueryMarker()
    not PMML()
then
    retract( $qm );
end


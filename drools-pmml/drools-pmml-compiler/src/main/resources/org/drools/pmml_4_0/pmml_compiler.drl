/*
 * Copyright 2011 JBoss Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.drools.pmml_4_0.descr.*;
import org.drools.pmml_4_0.ModelMarker;
import org.mvel2.templates.*;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;

global StringBuilder theory;
global TemplateRegistry registry;
global Map fld2var;
global PMML4Wrapper utils;



 function void applyTemplate(String templateName, Object context, TemplateRegistry registry, Map vars, StringBuilder builder) {
    CompiledTemplate template = (CompiledTemplate) registry.getNamedTemplate(templateName);
    if ( templateName.contains("svm")) {
        String t = TemplateRuntime.execute(template, context, vars).toString();
        System.err.println("TEMPLATE EXECT " + templateName +  " with params " + vars );
        System.err.println( t );
        builder.append( t );
    } else {
        builder.append( TemplateRuntime.execute(template, context, vars) );
    }
 }



// the function is repeated here because of rule processDerivedField_MapValues
    function String format(String type, String val) {
        if (type == null) {
            return val;
        } else if ("Integer".equalsIgnoreCase(type)) {
			return val;
		} else if ("Float".equalsIgnoreCase(type)) {
			return val;
		} else if ("Double".equalsIgnoreCase(type)) {
			return val;
		} else if ("Boolean".equalsIgnoreCase(type)) {
			return val;
		} else if ("String".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("Date".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("Time".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("DateTime".equalsIgnoreCase(type)) {
			return "\""+val+"\"";
		} else if ("DateDaysSince[0]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateDaysSince[1960]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateDaysSince[1970]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateDaysSince[1980]".equalsIgnoreCase(type)) {
			return val;
		} else if ("TimeSeconds".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[0]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[1960]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[1970]".equalsIgnoreCase(type)) {
			return val;
		} else if ("DateTimeSecondsSince[1980]".equalsIgnoreCase(type)) {
			return val;
		} else {
			return val;
		}
    }


//**********************************************************************************************************
//
//  COMPILATION RULES
//
//**********************************************************************************************************


//*********************************** HEADER SECTION *****************************************************//

rule "processHeader"
salience 9999
when
    $h : Header()
then
    HashMap map = new HashMap(7);
        map.put("pack",utils.getPack());
    applyTemplate("pmml_header.drlt", $h, registry, map, theory);
    retract($h);
end


//*********************************** DATA DICTIONARY ****************************************************//



declare FieldMarker
    name : String   @key
    dataType : DATATYPE
end

declare TypeOfField
    name : String     @key
    dataType : DATATYPE
end



declare QueryMarker
    name : String
    context : String
end




rule "processDataDictionary"
when
    $dic : DataDictionary( $flds : dataFields )
    eval( ! utils.isModelBeanDefined("DataField") )
then
    utils.addModelBeanDefinition("DataField");
    applyTemplate("rootDataField.drlt", utils, registry, new HashMap(), theory);
end


rule "typeOfDataField"
dialect "mvel"
when
    $fld : DataField( $n : name, $t : dataType )
then
    insert( new FieldMarker($n,$t) );
    insertLogical( new TypeOfField($n,$t) );
end



rule "processDataField_define"
dialect "mvel"
salience 1
when
    $fld : DataField( $n : name, $t : dataType)
    not FieldMarker( name == $n )
    eval( ! utils.isModelBeanDefined(utils.compactUpperCase($n)) )
then
    utils.addModelBeanDefinition( utils.compactUpperCase( $n ) );
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fullName", $fld.displayName );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "super", null );
        map.put( "type", utils.mapDatatype( $fld.dataType ) );
        map.put( "modelType", null );
        //map.put("cyclic",("1".equals($fld.isCyclic)));
        //map.put("categorical","categorical".equalsIgnoreCase($fld.optype.v alue));
        //map.put("continuous","continuous".equalsIgnoreCase($fld.optype.v alue));
        //map.put("ordinal","ordinal".equalsIgnoreCase($fld.optype.v alue));
    applyTemplate( "ioTypeDeclare.drlt", utils, registry, map, theory );
//    applyTemplate("updateIOField.drlt", utils, registry, map, theory);

end



rule "processDataField_entry"
dialect "mvel"
when
    $fld : DataField( $vals : values , $isize : intervals )
    $validVals : List( $vsize : size ) from collect (
        Value( property != "invalid", property != "missing" ) from $vals
    )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "fullName", $fld.displayName );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "type", utils.mapDatatype( $fld.dataType ) );
        map.put( "cyclic", ( "1".equals( $fld.isCyclic ) ) );
        map.put( "notRestricted", ( $isize.size() == 0 && $vsize == 0 ) );
        map.put( "categorical", "categorical".equalsIgnoreCase( $fld.optype.value ) );
        map.put( "continuous", "continuous".equalsIgnoreCase( $fld.optype.value ) );
        map.put( "ordinal", "ordinal".equalsIgnoreCase( $fld.optype.value ) );
    applyTemplate( "inputFromEP.drlt", utils, registry, map, theory );
end



rule "processDataField_interValidation_fixLeft"
salience 999
dialect "java"
when
    $fld : DataField( $ivals : intervals )
    $i : Interval( leftMargin == null ) from $ivals
then
    $i.setLeftMargin(-Double.MAX_VALUE);
end


rule "processDataField_interValidation_fixRight"
salience 999
dialect "mvel"
when
    $fld : DataField( $ivals : intervals )
    $i : Interval( rightMargin == null ) from $ivals
then
    $i.setRightMargin(Double.MAX_VALUE);
end

rule "processDataField_interValidation"
dialect "mvel"
when
    $fld : DataField( $vals : values , $isize : intervals.size() > 0,
                      optype == OPTYPE.CONTINUOUS || optype == OPTYPE.ORDINAL )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("ivals",$fld.intervals);
    applyTemplate("intervalsOnDomainRestriction.drlt", utils, registry, map, theory);
end



rule "processDataField_valueValidation_valid"
dialect "mvel"
when
    $fld : DataField( $vals : values, $vsize : values.size() > 0 )
    $validz : List( size > 0 ) from accumulate (
                        $val : Value( property == null || (property != "missing" && property != "invalid") ) from $vals,
                        init ( List validz = new java.util.LinkedList(); ),
                        action ( validz.add(utils.format($fld,$val)); ),
                        result ( validz )
                      )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("vals",$validz);
        map.put("field",$fld);
    applyTemplate("valuesOnDomainRestriction.drlt", utils, registry, map, theory);
end


rule "processDataField_valueValidation_missing"
dialect "mvel"
when
    $fld : DataField( $vals : values, $vsize : values.size() > 0,
                      ( optype == OPTYPE.CONTINUOUS || optype == OPTYPE.CATEGORICAL ) )
    $missingz : List( size > 0 ) from accumulate(
                        $val : Value( property == "missing" ) from $vals,
                        init( List missingz = new java.util.LinkedList(); ),
                        action( missingz.add(utils.format($fld,$val)); ),
                        result( missingz )
                      )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("vals",$missingz);
        map.put("field",$fld);
    applyTemplate("valuesOnDomainRestrictionMissing.drlt", utils, registry, map, theory);
end


rule "processDataField_valueValidation_invalid"
dialect "mvel"
when
    $fld : DataField( $vals : values, $vsize : values.size() > 0,
                      ( optype == OPTYPE.CONTINUOUS || optype == OPTYPE.CATEGORICAL ) )
    $invalidz : List( size > 0 ) from accumulate(
                        $val : Value( property == "invalid" ) from $vals,
                        init( List invalidz = new java.util.LinkedList(); ),
                        action( invalidz.add(utils.format($fld,$val)); ),
                        result( invalidz )
                      )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("vals",$invalidz);
        map.put("field",$fld);
    applyTemplate("valuesOnDomainRestrictionInvalid.drlt", utils, registry, map, theory);
end






//***************************************************************************************************************
//   TRANSFORMATIONS
//***************************************************************************************************************




//***************************************************************************************************************
//        Derived Fields definition
//              The transformationDictionary includes a set of derived field
//***************************************************************************************************************


rule "processDerivedField_define"
dialect "mvel"
salience 1
when
    $fld : DerivedField( $n : name, $t :  dataType )
    not FieldMarker( name == $n )
then
//    String opt = $fld.optype.v alue;
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("fullName",$fld.displayName);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("type",utils.mapDatatype($fld.dataType));
        map.put("super",null);
        map.put("modelType",null);
//        map.put("cyclic",false);
//        map.put("categorical","categorical".equalsIgnoreCase(opt));
//        map.put("continuous","continuous".equalsIgnoreCase(opt));
//        map.put("ordinal","ordinal".equalsIgnoreCase(opt));
    applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
//    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end


rule "typeOfDerivedField"
dialect "mvel"
when
    $fld : DerivedField( $n : name, $t : dataType )
then
    insert( new FieldMarker($n,$t) );
    insertLogical( new TypeOfField($n,$t) );
end



//******************************************************************************************************************
//        Linear Transformations
//          Normalization, piecewise continuous
//******************************************************************************************************************


rule "processDerivedField_linearize_missing"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous )
    NormContinuous( this == $nc, $mapMissing : mapMissingTo != null )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($nc.field));
        map.put("target",$mapMissing);
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end



rule "processDerivedField_linearize_piecewiseInterpolate"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms )
then
    int num = $tracts.size();
    int j = 1;
    while (j < num) {
        java.util.HashMap map = new java.util.HashMap();
            map.put("context",utils.context);
            map.put("name",utils.compactUpperCase($fld.name));
            map.put("origField",utils.compactUpperCase($nc.field));
            map.put("xmin",((LinearNorm) $tracts.get(j-1)).orig);
            map.put("ymin",((LinearNorm) $tracts.get(j-1)).norm);
            map.put("xmax",((LinearNorm) $tracts.get(j)).orig);
            map.put("ymax",((LinearNorm) $tracts.get(j)).norm);
            map.put("index",j);
            map.put("type",utils.mapDatatype($type));
        applyTemplate("linearTractNormalization.drlt", utils, registry, map, theory);
        j++;
    }
end


rule "processDerivedField_linearize_outliers_asMissing"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms, outliers == OUTLIERTREATMENTMETHOD.AS_MISSING_VALUES )
    $XMIN : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, min( $x ) )
    $XMAX : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, max( $x ) )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($nc.field));
        map.put("xmin",$XMIN);
        map.put("xmax",$XMAX);
        map.put("type",utils.mapDatatype($type));
    applyTemplate("normContOutliersAsMissing.drlt", utils, registry, map, theory);
end


//
rule "processDerivedField_linearize_outliers_asExtreme"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc, $tracts : linearNorms, outliers == OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES  )
    $XMIN : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, min( $x ) )
    $XMAX : Double() from accumulate ( LinearNorm( $x : orig ) from $tracts, max( $x ) )
    $YMIN : Double() from accumulate ( LinearNorm( $y : norm ) from $tracts, min( $y ) )
    $YMAX : Double() from accumulate ( LinearNorm( $y : norm ) from $tracts, max( $y ) )

then
    System.err.println("XXXXXXXXXXXXXXXXXXXXXXXXXX");
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $nc.field ) );
        map.put( "xmin", $XMIN );
        map.put( "xmax", $XMAX );
        map.put( "ymin", $YMIN );
        map.put( "ymax", $YMAX );
        map.put( "type", utils.mapDatatype( $type ) );
    applyTemplate( "boundedLowerOutliers.drlt", utils, registry, map, theory );
    applyTemplate( "boundedUpperOutliers.drlt", utils, registry, map, theory );
end

rule "processDerivedField_linearize_outliers_asExtrapolate"
dialect "mvel"
when
    $fld : DerivedField( $nc : normContinuous, $name : name  )
    TypeOfField( name == $name, $type : dataType )
    NormContinuous( this == $nc,  $tracts : linearNorms , $norms : linearNorms,
                    outliers != OUTLIERTREATMENTMETHOD.AS_MISSING_VALUES,
                    outliers != OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $nc.field ) );
        map.put( "xmin", ((LinearNorm) ( $tracts.get(0) ) ).orig );
        map.put( "xmax", ((LinearNorm) ( $tracts.get(1) ) ).orig );
        map.put( "ymin", ((LinearNorm) ( $tracts.get(0) ) ).norm );
        map.put( "ymax", ((LinearNorm) ( $tracts.get(1) ) ).norm );
        map.put( "index", 0);
        map.put( "type", utils.mapDatatype( $type ) );
    applyTemplate( "lowerExtrapolateLinearTractNormalization.drlt", utils, registry, map, theory );

    int $N = $norms.size();
        map.put("xmin",((LinearNorm) ( $tracts.get($N-2) ) ).orig );
        map.put("xmax",((LinearNorm) ( $tracts.get($N-1) ) ).orig );
        map.put("ymin",((LinearNorm) ( $tracts.get($N-2) ) ).norm );
        map.put("ymax",((LinearNorm) ( $tracts.get($N-1) ) ).norm );
        map.put("index",$N);
    applyTemplate( "upperExtrapolateLinearTractNormalization.drlt", utils, registry, map, theory );
end



//******************************************************************************************************************
//        Constants and References
//
//******************************************************************************************************************


rule "processDerivedField_constant"
dialect "mvel"
when
    $fld : DerivedField( $c : constant )
    Constant( this == $c, $x : value)
then
    HashMap map = new HashMap(7);
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "konst", $x );
    applyTemplate( "constantField.drlt", utils, registry, map, theory );
end



rule "processDerivedField_fieldRef"
dialect "mvel"
when
    $fld : DerivedField( $ref : fieldRef )
    FieldRef( this == $ref, $f : field)
then
    HashMap map = new HashMap(7);
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $f ) );
    applyTemplate( "aliasedField.drlt", utils, registry, map, theory );
end




 //******************************************************************************************************************
 //        NormDiscrete
 //
 //******************************************************************************************************************


rule "processDerivedField_normDiscrete_basicField"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $x : value)
    DataField( name == $f, $dataType : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $f ) );
        map.put( "target", utils.format( $dataType, $x ) );
    applyTemplate( "indicatorFieldYes.drlt", utils, registry, map, theory );
    applyTemplate( "indicatorFieldNo.drlt", utils, registry, map, theory );
end



rule "processDerivedField_normDiscrete_derivedField"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $x : value)
    DerivedField( name == $f, $dataType : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context);
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "origField", utils.compactUpperCase( $f ) );
        map.put( "target", utils.format( $dataType, $x ) );
    applyTemplate( "indicatorFieldYes.drlt", utils, registry, map, theory );
    applyTemplate( "indicatorFieldNo.drlt", utils, registry, map, theory );
end



rule "processDerivedField_normDiscrete_mapMissing"
dialect "mvel"
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd, $f : field , $m : mapMissingTo != null )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",$m);
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end


rule "processDerivedField_normDiscrete_cleanup"
dialect "mvel"
salience -5
when
    $fld : DerivedField( $nd : normDiscrete )
    NormDiscrete( this == $nd )
then
    retract($nd);
end

 //******************************************************************************************************************
 //       Binning / DiscretizeBin
 //
 //******************************************************************************************************************



rule "processDerivedField_Discretize_mapMissing"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $m : mapMissingTo != null , $dataType : dataType)
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("target",utils.format($dataType,$m));
    applyTemplate("mapMissingValues.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Discretize_propagateMissing"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $m : mapMissingTo == null )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
    applyTemplate("propagateMissingValues.drlt", utils, registry, map, theory);
end

rule "processDerivedField_Discretize_defaultnull"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue == null, $bins : discretizeBins )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("bins",$bins);
    applyTemplate("outOfBinningMissing.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Discretize_default"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue != null, $bins : discretizeBins, $dataType : dataType )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("bins",$bins);
        map.put("target",utils.format($dataType,$d));
    applyTemplate("outOfBinningDefault.drlt", utils, registry, map, theory);
end



rule "processDerivedField_Discretize_bin"
dialect "mvel"
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx, $f : field , $d : defaultValue != null, $bins : discretizeBins, $dataType : dataType )
    $bin : DiscretizeBin( $interval : interval, $x : binValue ) from $bins
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("origField",utils.compactUpperCase($f));
        map.put("intv",$interval);
        map.put("index",utils.nextCount());
        map.put("target",utils.format($dataType,$x));
    applyTemplate("intervalBinning.drlt", utils, registry, map, theory);
end



rule "processDerivedField_Discretize_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $dx : discretize )
    Discretize( this == $dx )
then
    retract($dx);
end

 //******************************************************************************************************************
 //     Value Mapping
 //
 //******************************************************************************************************************

declare MapSupportBean
   ref : MapValues
   columns : Map
   types : Map
end

rule "processDerivedField_MapValues_support_init"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map )
then
    MapSupportBean msb = new MapSupportBean();
        msb.setRef($map);
        msb.setColumns(new HashMap());
        msb.setTypes(new HashMap());
    insertLogical( msb );
end

rule "processDerivedField_MapValues_support"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $fcpairs : fieldColumnPairs )
    $sup : MapSupportBean( ref == $map )
    $fcp : FieldColumnPair() from $fcpairs
then
    $sup.columns.put($fcp.column, $fcp.field);
end


rule "processDerivedField_MapValues_support2"
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $fcpairs : fieldColumnPairs )
    $sup : MapSupportBean( ref == $map )
    $fcp : FieldColumnPair() from $fcpairs
    DataField( name == $fcp.field, $type : dataType )
then
    $sup.types.put($fcp.column, $type.value );
end


rule "processDerivedField_extract"
salience -1
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $rows : inlineTable.rows, $outColumn : outputColumn )
    $row : Row( $cells : content ) from $rows
then
    insertLogical( $row );
end


//TODO : can't use utils.format here, maybe a bug?
rule "processDerivedField_MapValues"
salience -2
dialect "mvel"
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map, $rows : inlineTable.rows, $outColumn : outputColumn )
    $sup : MapSupportBean( ref == $map,
                           $colMap : columns != null, $keys : columns.keySet,
                           $typeMap : types != null, $tkeys : types.keySet )
    $row : Row( $cells : content, this memberOf $rows )
    $fieldRestrMap : java.util.HashMap() from accumulate (
        org.w3c.dom.Element( $tag : tagName != $outColumn, $text : textContent,
                             tagName memberOf $keys, tagName memberOf $tkeys ) from $cells,
        init( java.util.HashMap restr = new java.util.HashMap(); ),
        action(
            restr.put($colMap.get($tag),format($typeMap.get($tag),$text));
        ),
        result( restr )
    )
    org.w3c.dom.Element( $tag : tagName == $outColumn, $target : textContent ) from $cells
then
    HashMap map = new HashMap( 7 );
        map.put( "context", utils.context );
        map.put( "name", utils.compactUpperCase( $fld.name ) );
        map.put( "patterns", $fieldRestrMap );
        map.put( "index", utils.nextCount() );
        map.put( "target", utils.format( $fld.dataType.value, $target ) );
    applyTemplate( "mapping.drlt", utils, registry, map, theory );
end



rule "processDerivedField_MapValues_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $map : mapValues )
    MapValues( this == $map )
then
    retract($map);
end



 //******************************************************************************************************************
 //     Aggregations
 //
 //******************************************************************************************************************

rule "processDerivedField_Collect"
dialect "mvel"
when
    $fld : DerivedField( $ag : aggregate )
    Aggregate( this == $ag, $func : this.function == "multiset",
                $groupBy : groupField, $afield : field, $constr : sqlWhere )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("groupBy",$groupBy);
        map.put("afield",$afield);
        map.put("constr",$constr);
    applyTemplate("collect.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Aggregation"
dialect "mvel"
when
    $fld : DerivedField( $ag : aggregate )
    Aggregate( this == $ag, $func : this.function != "multiset",
                $groupBy : groupField, $afield : field, $constr : sqlWhere )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("groupBy",$groupBy);
        map.put("afield",$afield);
        map.put("dataType",utils.mapDatatype($fld.dataType));
        map.put("constr",$constr);
        map.put("aggrFunc",$func);
    applyTemplate("aggregate.drlt", utils, registry, map, theory);
end


rule "processDerivedField_Aggregate_cleanup"
dialect "mvel"
salience -10
when
    $fld : DerivedField( $agg : aggregate )
    Aggregate( this == $agg )
then
    retract($agg);
end



 //******************************************************************************************************************
 //     Functions
 //
 //******************************************************************************************************************


declare FunctionResult
    expr : String
    father : Apply
end




rule "processDerivedField_Apply"
dialect "mvel"
salience -5
when
    $fld : DerivedField( $app : apply )
    $a : Apply( this == $app, $fun : this.function, $arity : constantsAndFieldRevesAndNormContinuouses.size() )
    $args : List( size == $arity ) from accumulate (
        $res : FunctionResult( father == $a, $x : expr ),
        init( List list = new LinkedList(); ),
        action( list.add($x); ),
        result ( list )
    )
then
    String funExpr = utils.mapFunction($fun, $args);
    //System.err.println(">>>>>>>>>>>>>>>>>>>>>>>>>  Built bit " + funExpr);

    Map exprFieldList = new java.util.LinkedHashMap();
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("dataType",utils.mapDatatype($fld.dataType));
        map.put("funExpr",funExpr);
        map.put("exprFieldList",fld2var);
    applyTemplate("apply.drlt", utils, registry, map, theory);

    retract($a);
    fld2var.clear();
end






rule "NestedConst"
dialect "mvel"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $c : Constant( this memberOf $expr, $x : value)
then
    //System.out.println("Visit const : " + $x + " child of " + $f);
    insertLogical( new FunctionResult($x, $a) );
end

rule "NestedRef"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $fr : FieldRef( this memberOf $expr, $x : field )
then
    //System.out.println("Visit field : " + $x + " child of " + $f + " || " + fld2var);
    if (! fld2var.containsKey($x)) {
        fld2var.put($x,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get($x), $a) );
end


rule "Scoop"
dialect "mvel"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $a2 : Apply( this memberOf $expr, $f2 : this.function, $arity : constantsAndFieldRevesAndNormContinuouses.size() )
    $args : List( size == $arity ) from accumulate (
        $res : FunctionResult( father == $a2, $x : expr ),
        init( List list = new LinkedList(); ),
        action( list.add($x); ),
        result ( list )
    )
then
    //System.err.println("Building bit for " + $f2 + " child of " + $f + " with args " + $args.size);
    String bit = utils.mapFunction($f2, $args);
    //System.err.println("Built bit " + bit + ", result for " + $f);
    insertLogical( new FunctionResult( bit , $a) );
    //System.err.println("Kill " + $f2 + "and its children results");
end




rule "NestedAggregate_onBasicField"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $agg : Aggregate( this memberOf $expr, $aggField : field )
    $super : DataField( name == $aggField, $optype : optype, $dataType : dataType)
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setOptype($optype);
        mockField.setDataType($dataType);
        mockField.setAggregate($agg);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put( name,"$var"+fld2var.size() );
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedAggregate_onDerivedField"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $agg : Aggregate( this memberOf $expr, $aggField : field )
    $super : DerivedField( name == $aggField, $optype : optype, $dataType : dataType)
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setOptype($optype);
        mockField.setDataType($dataType);
        mockField.setAggregate($agg);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedMapValues"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $map : MapValues( this memberOf $expr, $dataType : dataType  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType($dataType);
        mockField.setMapValues($map);
        mockField.setOptype(OPTYPE.CONTINUOUS);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedDiscretize"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $dix : Discretize( this memberOf $expr, $dataType : dataType  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType($dataType);
        mockField.setDiscretize($dix);
        mockField.setOptype(OPTYPE.CATEGORICAL);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end


rule "NestedNormContinuous"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $nct : NormContinuous( this memberOf $expr  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType(DATATYPE.DOUBLE);
        mockField.setNormContinuous($nct);
        mockField.setOptype(OPTYPE.CONTINUOUS);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end



rule "NestedNormDiscrete"
dialect "java"
salience -5
when
    $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $f : this.function )
    $ndx : NormDiscrete( this memberOf $expr  )
then
    String name = "Inner"+utils.nextCount();
    DerivedField mockField = new DerivedField();
        mockField.setName(name);
        mockField.setDataType(DATATYPE.DOUBLE);
        mockField.setNormDiscrete($ndx);
        mockField.setOptype(OPTYPE.CATEGORICAL);
    insertLogical(mockField);
    if (! fld2var.containsKey(name)) {
        fld2var.put(name,"$var"+fld2var.size());
    }
    insertLogical( new FunctionResult((String) fld2var.get(name), $a) );
end





  //******************************************************************************************************************
  //     User-defined Functions
  //
  //******************************************************************************************************************




 declare MatchContext
     father : Apply @key
     root : Apply @key
     body : Object
     params : Map
 end


 rule "visitApply_user_root"
 salience 15
 no-loop
 when
     $a : Apply( $args : constantsAndFieldRevesAndNormContinuouses, $fun : this.function  )
     DefineFunction( name == $fun, apply != $a )
     $df : DerivedField( apply == $a )
 then
     Apply idApply = new Apply();
         idApply.setFunction("identity");
         idApply.getConstantsAndFieldRevesAndNormContinuouses().add($a);
     $df.setNormContinuous(null);
     $df.setApply(idApply);
     retract($a);
     update($df);
 end



 rule "visitApply_user_nested"
 salience -1
 no-loop
 when
     $a : Apply( $expr : constantsAndFieldRevesAndNormContinuouses, $fun : this.function  )
     DefineFunction( name == $fun, $body : apply != $a, $paramFields : parameterFields )
     $father : Apply( $superArgs : constantsAndFieldRevesAndNormContinuouses contains $a )
     $params : java.util.LinkedHashMap() from accumulate (
         ParameterField( $name : name, $type : dataType ) from $paramFields,
         init( java.util.LinkedHashMap map = new java.util.LinkedHashMap(); int j = 0; ),
         action( map.put($name,new Integer(j++)); ),
         result( map )
     )
 then
     //System.out.println("\n\nINTERCEPTED USER-DEFINED APPLY " + $fun + " with params " + $params + " and args " + $expr.size() );


     // copy the function body to instantiate it
     Apply bodyInstance = (Apply) utils.copy($body);

     MatchContext mc = new MatchContext();
         mc.setFather($father);
         mc.setRoot($a);
         mc.setBody(bodyInstance.getConstantsAndFieldRevesAndNormContinuouses().get(0)); //body here is always identity
         mc.setParams($params);
     //System.out.println("\t About to insert context for");
     //System.out.println("\t\t father : " + $father);
     //System.out.println("\t\t root : " + $a);
     //System.out.println("\t\t body : " + mc.getBody());
     //System.out.println("\t\t ctx : " + $params + "\n\n");

     insert( mc );


 end



 rule "pre_visit_mc"
 no-loop
 salience 1000
 when
     MatchContext( $body : body )
 then
     insertLogical( $body );
 end


 rule "visit_mc"
 no-loop
 salience -1
 when
     MatchContext( $body : body, $params : params, $root : root )
     Apply( this == $root, $args : constantsAndFieldRevesAndNormContinuouses )
     $a : Apply( $bodyArgs : constantsAndFieldRevesAndNormContinuouses )
     $ref : FieldRef( this memberOf $bodyArgs, $fname : field )
     java.util.LinkedHashMap( keySet contains $fname ) from $params
 then
     //System.out.println("MC with body and args, found ref  " + $ref);

     int index = $bodyArgs.indexOf($ref);
     $bodyArgs.remove(index);
     Object arg = $args.get((Integer) $params.get($fname));
     $bodyArgs.add(index, utils.copy(arg));

     //System.out.println("REPLACE fieldRef in function " + $fname + " with " + arg + " in context " + $params);
 end









 rule "rebuildApply"
 salience -1
 no-loop
 when
     $mc : MatchContext( $father: father, $a : root, $newbody : body )
     Apply(  this == $a, $expr : constantsAndFieldRevesAndNormContinuouses, $fun : this.function  )
     DefineFunction( name == $fun )
     Apply( this == $father, $superArgs : constantsAndFieldRevesAndNormContinuouses )
 then
      //System.out.println("\t After some processing: matchContext ");
     //System.out.println("\t\t father : " + $mc.getFather());
     //System.out.println("\t\t root : " + $mc.getRoot());
     //System.out.println("\t\t body : " + $mc.getBody());
     //System.out.println("\t\t ctx : " + $mc.getParams() + "\n\n");
     retract($newbody);

     //System.out.println("REBUILD APPLY " + $fun + " with " + $newbody);
     int index = $superArgs.indexOf($a);
     $superArgs.remove(index);
     $superArgs.add(index,$newbody);

     //System.out.println("FATHER IS NOW  " + $father);
     retract($mc);
     update($father);
 end







//**********************************************************************************************************
//
//  MODELS
//
//**********************************************************************************************************

declare ModelStat
    neuralNetwork : boolean
end

rule "InitStats"
when

then
    insert(new ModelStat());
end









  //******************************************************************************************************************
  //     MiningSchema
  //
  //******************************************************************************************************************







rule "Preprocess_Inputs"
dialect "mvel"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs, usageType == FIELDUSAGETYPE.ACTIVE )
then
    //System.err.println("Found Mined Field " + $fld.name );
    HashMap map = new HashMap(7);
        map.put("name",utils.compactUpperCase($fld.name));
        map.put("model",utils.context);
    applyTemplate("miningField.drlt", utils, registry, map, theory);
end

rule "Create IO Trait"
dialect "mvel"
salience -10
when
    MiningSchema( $miningFields : miningFields )
    $fields : java.util.Map() from accumulate (
            MiningField( this memberOf $miningFields, $name : name, usageType == FIELDUSAGETYPE.ACTIVE )
            and
            TypeOfField( $n : name == $name, $type : dataType )
         ,
        init( Map map = new HashMap(); ),
        action( map.put( utils.compactUpperCase( $n ), $type ) ),
        result( map )
    )
then
    HashMap map = new HashMap(7);
        map.put("context",utils.context);
        map.put("fields", $fields );
    applyTemplate("ioTrait.drlt", utils, registry, map, theory);
end


rule "Preprocess_Inputs_InvalidsAsInvalid"
dialect "mvel"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs, usageType == FIELDUSAGETYPE.ACTIVE, invalidValueTreatment == INVALIDVALUETREATMENTMETHOD.RETURN_INVALID )
then
    //TODO : Do not eval, but return invalid !
end


rule "Preprocess_Inputs_InvalidsAsMissing"
dialect "java"
when
    MiningSchema(  $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        invalidValueTreatment == INVALIDVALUETREATMENTMETHOD.AS_MISSING, $val : missingValueReplacement )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context);
        map.put( "replacement", utils.format( utils.mapDatatype( $type ), $val ) );
    applyTemplate( "miningFieldInvalid.drlt", utils, registry, map, theory );
end






rule "Preprocess_Inputs_MissingReplacement"
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        $val : missingValueReplacement != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "replacement", utils.format( utils.mapDatatype( $type ), $val ) );
    applyTemplate( "miningFieldMissing.drlt", utils, registry, map, theory );
end




rule "Preprocess_Inputs_OutliersAsMissing" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        outliers == OUTLIERTREATMENTMETHOD.AS_MISSING_VALUES,
                        $low : lowValue, $upp : highValue )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap(7);
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("upp",utils.format(utils.mapDatatype($type),$upp));
        map.put("low",utils.format(utils.mapDatatype($type),$low));
    applyTemplate("miningFieldOutlierAsMissing.drlt", utils, registry, map, theory);
end


rule "Preprocess_Inputs_OutliersAsExtremeLow" //numeric only
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        $vaal : outliers == OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES,
                        //avoid mysterious reason why I can't use == "asExtremeValues" in the line above !?!?!
//                        $vaal.equals( "asExtremeValues" ),
                        $low : lowValue != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap(7);
        map.put("name",utils.compactUpperCase($name));
        map.put("model",utils.context);
        map.put("low",utils.format(utils.mapDatatype($type),$low));
    applyTemplate("miningFieldOutlierAsExtremeLow.drlt", utils, registry, map, theory);
end


rule "Preprocess_Inputs_OutliersAsExtremeUpp" //numeric only
dialect "java"
when
    MiningSchema( $inputs : miningFields )
    $fld : MiningField( this memberOf $inputs,  $name : name, usageType == FIELDUSAGETYPE.ACTIVE,
                        $vaal : outliers == OUTLIERTREATMENTMETHOD.AS_EXTREME_VALUES,
                        //avoid mysterious reason why I can't use == "asExtremeValues" in the line above !?!?!
//                        $vaal.equals( "asExtremeValues" ),
                        $upp : highValue != null )
    TypeOfField( name == $name, $type : dataType )
then
    HashMap map = new HashMap( 7 );
        map.put( "name", utils.compactUpperCase( $name ) );
        map.put( "model", utils.context );
        map.put( "upp", utils.format( utils.mapDatatype( $type ), $upp ) );
    applyTemplate( "miningFieldOutlierAsExtremeUpp.drlt", utils, registry, map, theory );
end


rule "BuildQuery"
when
    // can't use assertBehaviour.EQUALITY because of poorly formed PMML Descr
    $q: QueryMarker( $name : name, $context : context)
    not QueryMarker( this != $q, name == $name, context == $context )
then
    HashMap map = new HashMap( 7 );
             map.put( "model", $context );
             map.put( "field", $name);
    applyTemplate( "neuralOutputQuery.drlt", utils, registry, map, theory );
end

  //******************************************************************************************************************
    //    Targets
    //
    //******************************************************************************************************************


 rule "Generic_Target"
 when
    $t: Target( $field : field, targetValues.size() == 0,
                 $cast : castInteger, $max : max, $min : min, $offset : rescaleConstant, $scale : rescaleFactor  )
    MiningField( name == $field, usageType == FIELDUSAGETYPE.PREDICTED )
 then
     HashMap map = new HashMap(7);
         map.put("model",utils.context);
         map.put("field",utils.compactUpperCase($field));
         map.put("cast",$cast);
         map.put("min",$min);
         map.put("max",$max);
         map.put("offset",$offset);
         map.put("scale",$scale);
     applyTemplate("targetReshape.drlt", utils, registry, map, theory);
 end


 //******************************************************************************************************************
     //    Outputs
     //
     //******************************************************************************************************************




rule "Output_Type"
when
     $of : OutputField( $name : name, $dataType : dataType != null)
then
     insertLogical(new TypeOfField($name,$dataType));
end


  rule "Output_Type2"
  no-loop
  when
      $of : OutputField( $name : name, dataType == null, $tgt : targetField)
      TypeOfField( name == $tgt, $dataType : dataType )
  then
      insertLogical(new TypeOfField($name,$dataType));
  end




 rule "DeclareOutput_Neural"
 dialect "mvel"
 salience 1
 when
     $of : OutputField( $name : name, $tgt : targetField )
     $tf : TypeOfField( name == $name )
     $mod : OutputParentModel( field == $of, $mt : modelType )
     eval(! utils.isModelBeanDefined(utils.compactUpperCase($name)) )
 then
    utils.addModelBeanDefinition($name);
     HashMap map = new HashMap(7);
         map.put("context",utils.context);
         map.put("fullName",$of.displayName);
         map.put("name",utils.compactUpperCase($of.name));
         map.put("super","OutputField");
         map.put("modelType",$mt)
         map.put("type",utils.mapDatatype($tf.dataType));
     applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
     applyTemplate("updateIOField.drlt", utils, registry, map, theory);
 end

 rule "Output_Expose"
 when
     $of : OutputField( $name : name )
 then
      insert( new QueryMarker(utils.compactUpperCase($name),utils.context) );
 end




 rule "SimpleValueOutput"
 dialect "mvel"
 when
     $of : OutputField( $tgt : targetField, $val : value, $name : name, feature == null || feature == RESULTFEATURE.PREDICTED_VALUE )
     $tf : TypeOfField( name == $name, $type : dataType )
 then
     HashMap map = new HashMap(7);
         map.put("context",utils.context);
         map.put("origField",utils.compactUpperCase($tgt));
         map.put("name",utils.compactUpperCase($name));
         map.put("value",$val);
         map.put("type",$type);
     applyTemplate("aliasedOutput.drlt", utils, registry, map, theory);
 end





 rule "AddFeature_DisplayValue"
 dialect "mvel"
 when
     $of : OutputField( $tgt : targetField, $val : value, $name : name,
                        feature == RESULTFEATURE.PREDICTED_DISPLAY_VALUE )
     $tf : TypeOfField( name == $name, $type : dataType )
 then
     HashMap map = new HashMap( 7 );
         map.put( "context", utils.context );
         map.put( "origField", utils.compactUpperCase( $tgt ) );
         map.put( "name", utils.compactUpperCase( $name ) );
         map.put( "value", $val );
         map.put( "type", $type );
         map.put( "feature", "displayValue" );
     applyTemplate( "addOutputFeature.drlt", utils, registry, map, theory );
 end







  //******************************************************************************************************************
  //     NeuralNetwork
  //
  //******************************************************************************************************************





rule "setupNNs"
when
   NeuralNetwork( $name : modelName )
   $stat : ModelStat( neuralNetwork == false )
   eval( ! utils.isModelBeanDefined("Stym") )
then
   HashMap map = new HashMap(7);
        map.put("name", utils.compactUpperCase( $name ) );
        map.put("type","NeuralNetwork");
   applyTemplate("modelMark.drlt", null, registry, map, theory);

   utils.addModelBeanDefinition("Stym");
   utils.addModelBeanDefinition("Charge");
   utils.addModelBeanDefinition("Synapse");
   applyTemplate("neuralBeans.drlt", null, registry, null, theory);

   applyTemplate("neuralLinkSynapses.drlt", null, registry, null, theory);
   $stat.setNeuralNetwork(true);
   update($stat);
end



rule "visitNeuralNetwork_context"
salience -9
when
    $net : NeuralNetwork( $name : modelName )
then
    utils.context = utils.compactUpperCase($name);
end


rule "Neural_InputFieldGeneration"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralInputs( this memberOf $info, $nis : neuralInputs )
    $ni : NeuralInput( this memberOf $nis, $fld : derivedField, $id : id)
then
    String name = utils.compactUpperCase($nn)+"_"+$id;
    $fld.setName(name);
    insertLogical($fld);

    HashMap map = new HashMap(7);
        map.put("name",utils.compactUpperCase(name));
        map.put("context",utils.context);
        map.put("index",$id);
    applyTemplate("neuralWireInput.drlt", utils, registry, map, theory);
end


rule "Neural_DerivedInputFieldOverride"
dialect "mvel"
when
    NeuralInput( derivedField != null, $fld : derivedField.name != null)
then
    HashMap map = new HashMap(7);
        map.put("name",utils.compactUpperCase($fld));
        map.put("context",utils.context);
    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end

rule "Neural_RefInputFieldOverride"
dialect "mvel"
when
    NeuralInput( derivedField != null, $fld :derivedField.fieldRef != null)
then
    HashMap map = new HashMap(7);
        map.put("name",utils.compactUpperCase($fld.field));
        map.put("context",utils.context);
    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end




rule "SetDefaultActivation"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs, $act : activationFunction )
    $nl : NeuralLayer( this memberOf $info, activationFunction == null)
then
    $nl.setActivationFunction($act);
    update($nl);
end

rule "SetDefaultThreshold"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs, $thold : threshold )
    $nl : NeuralLayer( this memberOf $info, threshold == null)
then
    $nl.setThreshold($thold);
    update($nl);
end


rule "SetDefaultBias"
salience 100
when
    $n : Neuron( bias == null )
then
    $n.setBias(0.0);
    update($n);
end


rule "SetDefaultNormalization"
salience 100
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs,
                    $norm : normalizationMethod != null && normalizationMethod != NNNORMALIZATIONMETHOD.NONE )
    $nl : NeuralLayer( this memberOf $info, normalizationMethod == null)
then
    $nl.setNormalizationMethod($norm);
    update($nl);
end

rule "Synapses"
salience -10
when
    $n : Neuron( $links : cons, $index : id )
then
    HashMap map = new HashMap(7);
        map.put("model",utils.context);
        map.put("index",$index);
        map.put("links",$links);
    applyTemplate("neuralBuildSynapses.drlt", utils, registry, map, theory);
end


rule "Neuron"
salience -9
when
    NeuralLayer( $ns : neurons, $act : activationFunction != null, $thold : threshold != null, $norm : normalizationMethod )
    $n : Neuron( this memberOf $ns, $index : id, $bias : bias != null, $in : cons )
then
    //System.err.println("CREATE NEURON RULE FOR " + $index + " >> " + $act + "  " + $bias + "  " + $thold);

     HashMap map = new HashMap(7);
        map.put("model",utils.context);
        map.put("index",$index);
        map.put("actFun",$act);
        map.put("needsNormal",$norm != null );
        map.put("bias",$bias);
        map.put("thold",$thold);
        map.put("inLink",$in.size());
    applyTemplate("neuralFire.drlt", utils, registry, map, theory);
end


rule "Neural_Layer_Max_Normalization"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $nl : NeuralLayer( this memberOf $info, $ns : neurons,
                 normalizationMethod != null && normalizationMethod == NNNORMALIZATIONMETHOD.SIMPLEMAX )
then
    HashMap map = new HashMap(7);
        map.put("model",utils.context);
        map.put("neurons",$ns);
        map.put("j",utils.nextCount());
    applyTemplate("neuralLayerMaxNormalization.drlt", utils, registry, map, theory);
end


rule "Neural_Layer_Max_SoftNormalization"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $nl : NeuralLayer( this memberOf $info, $ns : neurons,
                 normalizationMethod != null && normalizationMethod == NNNORMALIZATIONMETHOD.SOFTMAX )
then
    HashMap map = new HashMap(7);
        map.put("model",utils.context);
        map.put("neurons",$ns);
        map.put("j",utils.nextCount());
    applyTemplate("neuralLayerSoftMaxNormalization.drlt", utils, registry, map, theory);
end



rule "Neural_Output_Field_Def"
salience -9
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
then
    String name = utils.compactUpperCase($nn)+"_"+$id;

    HashMap map = new HashMap(7);
        map.put("model",utils.context);
        map.put("name",name);
        map.put("index",$id);
    applyTemplate("neuralOutputField.drlt", utils, registry, map, theory);

    map = new HashMap();
        map.put("context",utils.context);
        map.put("fullName",name);
        map.put("name",name);
        map.put("super",null);
        map.put("type",utils.mapDatatype(DATATYPE.DOUBLE));
        map.put("cyclic",false);
        map.put("categorical",false);
        map.put("continuous",true);
        map.put("ordinal",false);
        map.put("modelType",null);
    applyTemplate("ioTypeDeclare.drlt", utils, registry, map, theory);
    applyTemplate("updateIOField.drlt", utils, registry, map, theory);
end

/*
 rule "Neural_Output_Expose"
 salience -9
 when
     NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
     NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
     $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
 then
     String name = utils.compactUpperCase($nn)+"_"+$id;
     insert( new QueryMarker(name,utils.context) );

     HashMap map = new HashMap(7);
         map.put("name",name);
     applyTemplate("confirm.drlt", utils, registry, map, theory);
 end
*/



rule "Neural_Output_Invert_NormContinuous"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName, functionName == MININGFUNCTION.REGRESSION )
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df : DerivedField( $norm : normContinuous != null ) from $fld
    NormContinuous( $mmt : mapMissingTo, $field : field, $outl : outliers, $ls : linearNorms ) from $norm
then

    //insert( new QueryMarker(utils.compactUpperCase($field),utils.context) );

    NormContinuous invertedNC = new NormContinuous();
        invertedNC.setMapMissingTo($mmt);
        invertedNC.setField(utils.compactUpperCase($nn)+"_"+$id);
        invertedNC.setOutliers($outl);
        for (int j = 0; j < $ls.size(); j++) {
            LinearNorm orig = (LinearNorm) $ls.get(j);
            LinearNorm inv = new LinearNorm();
                inv.setNorm(orig.getOrig());
                inv.setOrig(orig.getNorm());
            invertedNC.getLinearNorms().add(inv);
        }

//    HashMap map = new HashMap(7);
//        map.put("name",utils.compactUpperCase($field));
//    applyTemplate("confirm.drlt", utils, registry, map, theory);

    $df.setName($field);
    $df.setNormContinuous(invertedNC);

    insertLogical($df);
    insertLogical(invertedNC);
end




rule "Neural_Output_Invert_NormDiscrete_asPredicate"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName, functionName == MININGFUNCTION.CLASSIFICATION )
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df : DerivedField( $norm : normDiscrete != null) from $fld
    NormDiscrete( $field : field, $val : value ) from $norm
    TypeOfField( name == $field, $type : dataType )
then
    HashMap map = new HashMap(7);
        map.put( "model", utils.context );
        map.put( "field", utils.compactUpperCase($field) );
        map.put( "label", $val );
        map.put( "target", utils.format($type,utils.compactUpperCase( $val ) ) );
    applyTemplate( "neuralOutputQueryPredicate.drlt", utils, registry, map, theory );

    map = new HashMap();
        map.put( "name", utils.compactUpperCase( $field ) );
        map.put( "model", utils.context );
        map.put( "target", utils.format( $type, $val ) );
        map.put( "origField", utils.compactUpperCase( $nn )+"_"+$id );
    applyTemplate( "predicateField.drlt", utils, registry, map, theory );
end



rule "Neural_Output_Invert_FieldRef"
salience -15
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    NeuralOutputs( this memberOf $info, $outs : neuralOutputs )
    $out : NeuralOutput( $id : outputNeuron, $fld : derivedField )
    $df : DerivedField( $ref : fieldRef != null ) from $fld
    FieldRef( $field : field ) from $ref
then

    //insert( new QueryMarker(utils.compactUpperCase($field),utils.context) );

    $df.setName($field);
    $ref.setField(utils.compactUpperCase($nn)+"_"+$id);

    insertLogical($ref);
    insertLogical($fld);
end








  //******************************************************************************************************************
  //     Tree
  //
  //******************************************************************************************************************



rule "TreeRoot"
when
    $tree : TreeModel()
then
    System.err.println("COmpiling tree");
end

rule "visitTree_context"
salience -9
when
    $net : TreeModel( $name : modelName )
then
    System.out.println("Set context, now is " + $name);
    utils.context = utils.compactUpperCase($name);
end

rule "CompileNode"
when
    $node : Node( $nid : id, $score : score, nodes != null, $c : nodes )
then
    System.err.println( $node + "  " + $nid + " / " + $score + " | " + $c.size() );
end

rule "CompileLeaf"
when
    $node : Node( $nid : id, $score : score, nodes == null)
then
    System.err.println( "LEAF " + $node + "  " + $nid + " / " + $score );
end





  //******************************************************************************************************************
  //     SVM
  //
  //******************************************************************************************************************



rule "SVMRoot"
when
    $svm : SupportVectorMachineModel()
then
    applyTemplate( "svmDeclare.drlt", utils, registry, null, theory );
    applyTemplate( "svmFunctions.drlt", utils, registry, null, theory );
    applyTemplate( "svmOutputGeneration.drlt", utils, registry, null, theory );
end

rule "visitSVM_context"
salience -9
when
    $svm : SupportVectorMachineModel( $name : modelName )
then
    System.out.println( "Set context, now is " + $name );
    utils.context = utils.compactUpperCase( $name );
end


rule "visitSVM_SVM_Params"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $svm  : SupportVectorMachine( this memberOf $info,
                                  $bias : coefficients.absoluteValue,
                                  $noc : coefficients.numberOfCoefficients,
                                  $nos : supportVectors.numberOfSupportVectors,
                                  $coeffs : coefficients, $svs : supportVectors )
    $dic : VectorDictionary( this memberOf $info, $vlist : vectorInstances )
    accumulate( Coefficient( $val : value ),
                $cx : collectList( $val );
                $cx.size == $noc )
    accumulate( SupportVectorReference( $index : index, supportVector memberOf $svs.supportVectors ),
                $ix : collectList ( $index );
                $ix.size == $nos )
then
     HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "svmId", utils.context + utils.nextCount() );
            map.put( "absoluteValue", $bias );
            map.put( "indexes", $ix );
            map.put( "coeffs", $cx );
     applyTemplate( "svmBuild.drlt", utils, registry, map, theory );
end



declare SupportVectorReference
    vectorInstance : VectorInstance
    supportVector  : SupportVector
    index          : int
    sparse         : boolean
end

rule "Join Support Vectors and Instances"
when
    $sm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $dx : VectorDictionary( this memberOf $info, $vlist : vectorInstances )
    $sv : SupportVector( $vid : vectorId )
    $vi : VectorInstance( id == $vid, this memberOf $vlist )
then
    System.out.println( "Insert SVR " );
    insertLogical( new SupportVectorReference( $vi, $sv, $vlist.indexOf ( $vi ), $vi.getREALSparseArray() != null ) );
end

rule "SVM_InitSupportVectors"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $svm  : SupportVectorMachine( this memberOf $info,
                                  $nos : supportVectors.numberOfSupportVectors,
                                  $svs : supportVectors,
                                  $nat : supportVectors.numberOfAttributes )
    accumulate( $svr : SupportVectorReference( $index : index, supportVector memberOf $svs.supportVectors ),
                $ix : collectList ( $svr );
                $ix.size == $nos )
then
     HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "size", $nat.intValue() );
            map.put( "vectors", $ix );
     applyTemplate( "svmInitSupportVector.drlt", utils, registry, map, theory );
end



rule "SVM_InputVector"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries  )
    $vd   : VectorDictionary( this memberOf $info, $flds : vectorFields.fieldReves )
then
     HashMap map = new HashMap(3);
            map.put( "modelName", utils.context );
            map.put( "inputVectors", $flds );
     applyTemplate( "svmInitInputVector.drlt", utils, registry, map, theory );
end



rule "SVM_KernelEvals_RBF"
salience -16
when
    $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
    $rbkt : RadialBasisKernelType ( this memberOf $info, $gamma : gamma )
then
     HashMap map = new HashMap(7);
            map.put( "modelName", utils.context );
            map.put( "kernelType", "rbf" );
     applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
            map.put( "gamma", $gamma );
            map.put( "coef0", 0.0 );
            map.put( "degree", 0.0 );
     applyTemplate( "svmParams.drlt", utils, registry, map, theory );

end

rule "SVM_KernelEvals_POLY"
   salience -16
   when
       $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
       $pkt : PolynomialKernelType ( this memberOf $info, $gamma : gamma, $coef0 : coef0, $degree : degree )
   then
        HashMap map = new HashMap(7);
               map.put( "modelName", utils.context );
               map.put( "kernelType", "poly" );
        applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
               map.put( "gamma", $gamma );
               map.put( "coef0", $coef0 );
               map.put( "degree", $degree );
        applyTemplate( "svmParams.drlt", utils, registry, map, theory );
   end

rule "SVM_KernelEvals_LINEAR"
   salience -16
   when
       $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
       $lkt : LinearKernelType ( this memberOf $info )
   then
        HashMap map = new HashMap(7);
               map.put( "modelName", utils.context );
               map.put( "kernelType", "linear" );
        applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
               map.put( "gamma", 0.0 );
               map.put( "coef0", 0.0 );
               map.put( "degree", 0.0 );
        applyTemplate( "svmParams.drlt", utils, registry, map, theory );
   end

rule "SVM_KernelEvals_SIMOID"
   salience -16
   when
       $svmm : SupportVectorMachineModel( $info : extensionsAndSupportVectorMachinesAndVectorDictionaries )
       $pkt : SigmoidKernelType ( this memberOf $info, $gamma : gamma, $coef0 : coef0)
   then
        HashMap map = new HashMap(7);
               map.put( "modelName", utils.context );
               map.put( "kernelType", "sigmoid" );
        applyTemplate( "svmKernelEval.drlt", utils, registry, map, theory );
               map.put( "gamma", $gamma );
               map.put( "coef0", $coef0 );
               map.put( "degree", 0.0 );
        applyTemplate( "svmParams.drlt", utils, registry, map, theory );
   end


rule "SVM_Cleanup"
salience -20
when
    $svm : SupportVectorMachineModel( )
then
    utils.context = null;
    retract($svm);
end







  //******************************************************************************************************************
  //     Cleanup
  //
  //******************************************************************************************************************








rule "Clean_WM_Pre"
salience -18
dialect "mvel"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $ms : MiningSchema( this memberOf $info, $fields : miningFields )
    $fld : MiningField( usageType != null &&
                 ( usageType == FIELDUSAGETYPE.PREDICTED || usageType == FIELDUSAGETYPE.SUPPLEMENTARY )
               ) from $fields
then
    $fields.remove($fld);
end


rule "Clean_WM"
salience -19
dialect "mvel"
when
    NeuralNetwork( $info : extensionsAndNeuralLayersAndNeuralInputs , $nn : modelName)
    $ms : MiningSchema( this memberOf $info, $fields : miningFields )
then
    HashMap map = new HashMap( 7 );
        map.put( "model", utils.context );
        map.put( "fields", $fields );
    applyTemplate( "neuralClean.drlt", utils, registry, map, theory );
end



rule "Neural_Cleanup"
salience -20
when
    $nn : NeuralNetwork( )
then
    utils.context = null;
    retract( $nn );
end


//**********************************************************************************************************
//
//  INTEGRITY RULES
//
//**********************************************************************************************************


rule "checkDataDictionary"
when
    DataDictionary( $exp : numberOfFields != null, $act : dataFields.size() != $exp )
then
   System.err.println("TODO WARNING : Expected number of fields in datadictionary different from actual : " + $exp + " vs " + $act);
end





rule "CleanOnFinish_DataField"
salience -9999
when
    $df : DataField()
    not PMML()
then
    retract($df);
end

rule "CleanOnFinish_ModelStat"
salience -9999
when
    $ms : ModelStat()
    not PMML()
then
    retract($ms);
end

rule "CleanOnFinish_Qry"
salience -9999
when
    $qm : QueryMarker()
    not PMML()
then
    retract($qm);
end

